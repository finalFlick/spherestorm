<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Megabonk 3D POC</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-container { width: 100vw; height: 100vh; position: relative; }
        #hud { position: absolute; top: 0; left: 0; right: 0; padding: 20px; pointer-events: none; z-index: 100; }
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        .hud-left, .hud-right { background: rgba(0, 0, 0, 0.7); padding: 15px 20px; border-radius: 10px; color: white; }
        .hud-center { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); padding: 10px 25px; border-radius: 10px; color: white; text-align: center; }
        .arena-info { font-size: 14px; color: #ffdd44; margin-bottom: 5px; }
        .wave-info { font-size: 18px; font-weight: bold; }
        .stat-label { font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        .stat-value { font-size: 24px; font-weight: bold; }
        .health-bar-container { width: 200px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; margin-top: 5px; }
        .health-bar { height: 100%; background: linear-gradient(90deg, #ff4444, #ff6666); transition: width 0.3s ease; }
        .xp-bar-container { width: 200px; height: 12px; background: #333; border-radius: 6px; overflow: hidden; margin-top: 5px; }
        .xp-bar { height: 100%; background: linear-gradient(90deg, #44ff44, #88ff88); transition: width 0.3s ease; }
        .level-display { color: #ffdd44; font-size: 18px; margin-top: 5px; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; pointer-events: none; z-index: 100; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.8); }
        #crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
        #crosshair::after { width: 100%; height: 2px; top: 50%; transform: translateY(-50%); }
        #upgrade-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 30px; border-radius: 15px; border: 2px solid #ffdd44; display: none; z-index: 200; pointer-events: auto; }
        #upgrade-menu h2 { color: #ffdd44; text-align: center; margin-bottom: 20px; font-size: 28px; }
        .upgrade-options { display: flex; gap: 15px; }
        .upgrade-card { width: 180px; padding: 20px; background: linear-gradient(135deg, #1a1a2e, #16213e); border: 2px solid #444; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; text-align: center; color: white; }
        .upgrade-card:hover { border-color: #ffdd44; transform: translateY(-5px); box-shadow: 0 10px 30px rgba(255, 221, 68, 0.3); }
        .upgrade-icon { font-size: 40px; margin-bottom: 10px; }
        .upgrade-name { font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #ffdd44; }
        .upgrade-desc { font-size: 12px; color: #aaa; }
        #start-screen { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #0a0a1a, #1a1a3e); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 300; color: white; }
        #start-screen h1 { font-size: 64px; color: #ffdd44; text-shadow: 0 0 30px rgba(255, 221, 68, 0.5); margin-bottom: 20px; }
        #start-screen p { font-size: 18px; color: #888; margin-bottom: 40px; }
        #start-btn { padding: 20px 60px; font-size: 24px; background: linear-gradient(135deg, #ffdd44, #ffaa00); border: none; border-radius: 10px; cursor: pointer; color: #000; font-weight: bold; transition: all 0.3s ease; }
        #start-btn:hover { transform: scale(1.1); box-shadow: 0 10px 40px rgba(255, 221, 68, 0.5); }
        .controls-info { margin-top: 40px; text-align: center; color: #666; font-size: 14px; }
        .controls-info span { display: inline-block; background: #333; padding: 5px 12px; border-radius: 5px; margin: 3px; }
        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 40px 60px; border-radius: 15px; border: 2px solid #ff4444; display: none; z-index: 250; text-align: center; color: white; }
        #game-over h2 { color: #ff4444; font-size: 48px; margin-bottom: 20px; }
        .final-stats { margin: 20px 0; font-size: 18px; }
        .final-stats div { margin: 10px 0; }
        #restart-btn { padding: 15px 40px; font-size: 20px; background: linear-gradient(135deg, #ff4444, #ff6666); border: none; border-radius: 10px; cursor: pointer; color: white; font-weight: bold; margin-top: 20px; transition: all 0.3s ease; }
        #restart-btn:hover { transform: scale(1.05); }
        #kill-counter { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); padding: 10px 30px; border-radius: 20px; color: white; font-size: 18px; z-index: 100; }
        #damage-flash { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255, 0, 0, 0.3); pointer-events: none; opacity: 0; z-index: 50; transition: opacity 0.1s ease; }
        #pause-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.8); padding: 30px 50px; border-radius: 15px; color: white; font-size: 24px; text-align: center; z-index: 150; display: none; }
        #pause-indicator p { margin-top: 15px; font-size: 16px; color: #888; }
        #wave-announcement { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; pointer-events: none; z-index: 120; opacity: 0; transition: opacity 0.3s ease; }
        #wave-announcement.visible { opacity: 1; }
        #wave-announcement .wave-text { font-size: 64px; font-weight: bold; color: #ffdd44; text-shadow: 0 0 30px rgba(255, 221, 68, 0.7); }
        #wave-announcement .arena-text { font-size: 24px; color: #aaa; margin-top: 10px; }
        #boss-health-container { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); width: 400px; background: rgba(0, 0, 0, 0.8); padding: 15px 20px; border-radius: 10px; border: 2px solid #ff4444; display: none; z-index: 100; }
        #boss-name { text-align: center; color: #ff4444; font-size: 20px; font-weight: bold; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px; }
        #boss-health-bar-bg { width: 100%; height: 20px; background: #333; border-radius: 10px; overflow: hidden; }
        #boss-health-bar { height: 100%; background: linear-gradient(90deg, #ff2222, #ff6644); transition: width 0.3s ease; width: 100%; }
        #unlock-notification { position: absolute; top: 30%; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, rgba(68, 255, 68, 0.9), rgba(34, 180, 34, 0.9)); padding: 20px 40px; border-radius: 15px; color: white; font-size: 24px; font-weight: bold; text-align: center; z-index: 130; opacity: 0; pointer-events: none; transition: opacity 0.5s ease; }
        #unlock-notification.visible { opacity: 1; }
        #unlock-notification .unlock-title { font-size: 16px; color: rgba(255,255,255,0.8); margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="damage-flash"></div>
        <div id="hud">
            <div class="hud-top">
                <div class="hud-left">
                    <div class="stat-label">Health</div>
                    <div class="health-bar-container"><div class="health-bar" id="health-bar"></div></div>
                    <div class="level-display">Level <span id="level">1</span></div>
                    <div class="stat-label" style="margin-top: 10px;">XP</div>
                    <div class="xp-bar-container"><div class="xp-bar" id="xp-bar"></div></div>
                </div>
                <div class="hud-center">
                    <div class="arena-info">Arena <span id="arena-num">1</span> - <span id="arena-name">The Proving Grounds</span></div>
                    <div class="wave-info">Wave <span id="wave-num">1</span> / <span id="waves-total">10</span></div>
                </div>
                <div class="hud-right">
                    <div class="stat-label">Time</div>
                    <div class="stat-value" id="timer">0:00</div>
                    <div class="stat-label" style="margin-top: 10px;">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
            </div>
        </div>
        <div id="crosshair"></div>
        <div id="kill-counter">Kills: <span id="kills">0</span></div>
        <div id="wave-announcement"><div class="wave-text">WAVE 1</div><div class="arena-text">Arena 1 - The Proving Grounds</div></div>
        <div id="boss-health-container"><div id="boss-name">THE GUARDIAN</div><div id="boss-health-bar-bg"><div id="boss-health-bar"></div></div></div>
        <div id="unlock-notification"><div class="unlock-title">NEW MECHANIC UNLOCKED</div><div id="unlock-text">PILLARS & COVER</div></div>
        <div id="pause-indicator">PAUSED<p>Click anywhere to resume</p></div>
        <div id="upgrade-menu"><h2>LEVEL UP!</h2><div class="upgrade-options" id="upgrade-options"></div></div>
        <div id="game-over"><h2>GAME OVER</h2><div class="final-stats"><div>Time Survived: <span id="final-time"></span></div><div>Arena Reached: <span id="final-arena"></span></div><div>Level Reached: <span id="final-level"></span></div><div>Enemies Killed: <span id="final-kills"></span></div><div>Final Score: <span id="final-score"></span></div></div><button id="restart-btn">Play Again</button></div>
        <div id="start-screen"><h1>MEGABONK 3D</h1><p>Survive the arenas. Defeat the bosses. Unlock new challenges.</p><button id="start-btn">START GAME</button><div class="controls-info"><div><span>WASD</span> Move <span>SPACE</span> Jump <span>SHIFT</span> Dash</div><div><span>MOUSE</span> Look around <span>CLICK</span> Lock cursor</div><div style="margin-top: 15px;"><span>M</span> Toggle Music</div></div></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        'use strict';
        const WAVES_PER_ARENA = 10, DAMAGE_COOLDOWN = 500, PLAYER_JUMP_VELOCITY = 0.4, PLAYER_GRAVITY = 0.018;
        const BOUNCE_FACTORS = [0.45, 0.2, 0.08], TRAIL_MAX = 60, TRAIL_LIFETIME = 90, TRAIL_SPAWN_DISTANCE = 0.3;
        const HEART_DROP_CHANCE = { normal: 0.03, elite: 0.10, boss: 1.0 };
        const HEART_HEAL = { normal: 15, elite: 25, boss: 50 }, HEART_TTL = 600;
        
        // Enemy Types with weighted spawning
        const ENEMY_TYPES = {
            grunt: { name: 'Grunt', size: 0.5, health: 12, speed: 0.035, damage: 10, color: 0xff4466, xpValue: 1, behavior: 'chase', spawnWeight: 40 },
            shooter: { name: 'Shooter', size: 0.45, health: 8, speed: 0.025, damage: 8, color: 0x44ff66, xpValue: 2, behavior: 'shooter', shootRange: 15, shootCooldown: 2000, spawnWeight: 25 },
            shielded: { name: 'Shielded', size: 0.6, health: 30, speed: 0.02, damage: 12, color: 0x6666ff, xpValue: 3, behavior: 'chase', damageReduction: 0.5, spawnWeight: 15 },
            fastBouncer: { name: 'Fast Bouncer', size: 0.35, health: 6, speed: 0.12, damage: 8, color: 0xffff44, xpValue: 3, behavior: 'bouncer', spawnWeight: 10, minArena: 2 },
            splitter: { name: 'Splitter', size: 0.7, health: 20, speed: 0.03, damage: 10, color: 0xff44ff, xpValue: 4, behavior: 'chase', onDeath: 'split', splitCount: 3, spawnWeight: 8, minArena: 2 },
            shieldBreaker: { name: 'Shield Breaker', size: 0.55, health: 15, speed: 0.04, damage: 18, color: 0xff8844, xpValue: 4, behavior: 'shieldBreaker', rushRange: 8, rushSpeed: 0.15, spawnWeight: 8, minArena: 3 },
            waterBalloon: { name: 'Water Balloon', size: 0.4, health: 25, speed: 0.015, damage: 5, color: 0x44ffff, xpValue: 6, behavior: 'waterBalloon', growRate: 0.002, maxSize: 1.2, explosionRadius: 4, spawnWeight: 4, minArena: 3 },
            teleporter: { name: 'Teleporter', size: 0.45, health: 12, speed: 0.03, damage: 15, color: 0xaa44ff, xpValue: 5, behavior: 'teleporter', teleportCooldown: 3000, teleportRange: 8, spawnWeight: 4, minArena: 4 }
        };
        
        // Progressive Arena Configuration
        const ARENA_CONFIG = {
            wavesPerArena: WAVES_PER_ARENA,
            arenas: {
                1: { name: 'The Proving Grounds', features: ['flat'], color: 0x2a2a4a },
                2: { name: 'Pillar Sanctum', features: ['flat', 'pillars'], color: 0x2a3a4a },
                3: { name: 'Sky Rise', features: ['flat', 'pillars', 'vertical'], color: 0x3a2a4a },
                4: { name: 'Platform Gardens', features: ['flat', 'pillars', 'vertical', 'platforms'], color: 0x2a4a3a },
                5: { name: 'The Labyrinth', features: ['flat', 'pillars', 'vertical', 'platforms', 'tunnels'], color: 0x4a2a3a },
                6: { name: 'Chaos Realm', features: ['flat', 'pillars', 'vertical', 'platforms', 'tunnels', 'hazards'], color: 0x3a3a3a }
            }
        };
        
        // Enhanced Boss Configuration
        const BOSS_CONFIG = {
            1: { name: 'THE PILLAR GUARDIAN', health: 400, damage: 20, size: 2.5, color: 0xff2222, ai: 'pillarGuardian' },
            2: { name: 'THE SLIME QUEEN', health: 550, damage: 22, size: 2.8, color: 0x44ff88, ai: 'slimeQueen' },
            3: { name: 'THE TELEPORTING TYRANT', health: 700, damage: 28, size: 3.0, color: 0xaa44ff, ai: 'teleportingTyrant' },
            4: { name: 'THE BALLOON KING', health: 850, damage: 25, size: 3.2, color: 0x44ffff, ai: 'balloonKing' },
            5: { name: 'THE TUNNEL WYRM', health: 1000, damage: 32, size: 3.5, color: 0xff44ff, ai: 'tunnelWyrm' },
            6: { name: 'CHAOS INCARNATE', health: 1500, damage: 40, size: 4.0, color: 0xffffff, ai: 'chaosIncarnate' }
        };
        
        const WAVE_STATE = { WAVE_INTRO: 'WAVE_INTRO', WAVE_ACTIVE: 'WAVE_ACTIVE', WAVE_CLEAR: 'WAVE_CLEAR', BOSS_INTRO: 'BOSS_INTRO', BOSS_ACTIVE: 'BOSS_ACTIVE', BOSS_DEFEATED: 'BOSS_DEFEATED', ARENA_TRANSITION: 'ARENA_TRANSITION' };
        
        const gameState = {
            running: false, paused: false, health: 100, maxHealth: 100, xp: 0, xpToLevel: 10, level: 1, kills: 0, score: 0, pendingLevelUps: 0,
            currentArena: 1, currentWave: 1, waveState: WAVE_STATE.WAVE_INTRO, waveTimer: 0, enemiesToSpawn: 0, waveEnemiesRemaining: 0, lastWaveSpawn: 0, bossActive: false,
            unlockedMechanics: { pillars: false, ramps: false, platforms: false, tunnels: false, hybridChaos: false },
            unlockedEnemyBehaviors: { jumping: false, ambush: false, multiLevel: false },
            stats: { damage: 10, attackSpeed: 1, projectileCount: 1, projectileSpeed: 0.8, moveSpeed: 0.15, maxHealth: 100, pickupRange: 3, xpMultiplier: 1 }
        };

        let scene, camera, renderer, player, ground;
        let enemies = [], projectiles = [], enemyProjectiles = [], xpGems = [], hearts = [], particles = [], obstacles = [], hazardZones = [];
        let currentBoss = null, arenaWalls = [];
        const tempVec3 = new THREE.Vector3(), tempVec3_2 = new THREE.Vector3(), tempVec3_3 = new THREE.Vector3();
        let trailPool = [], trailIndex = 0, lastTrailPos = null;
        const keys = {};
        let cameraAngleX = 0, cameraAngleY = 0.3, isPointerLocked = false;
        let lastShot = 0, gameStartTime = 0, lastDash = 0, isDashing = false, dashDirection = new THREE.Vector3(), lastDamageTime = 0, lastUIUpdate = 0;
        const UI_UPDATE_INTERVAL = 100;
        
        const upgrades = [
            { name: 'Damage Up', icon: 'âš”ï¸', desc: '+25% damage', stat: 'damage', mult: 1.25 },
            { name: 'Attack Speed', icon: 'âš¡', desc: '+20% fire rate', stat: 'attackSpeed', mult: 1.2 },
            { name: 'Multi Shot', icon: 'ðŸŽ¯', desc: '+1 projectile', stat: 'projectileCount', add: 1 },
            { name: 'Speed Boost', icon: 'ðŸ‘Ÿ', desc: '+15% move speed', stat: 'moveSpeed', mult: 1.15 },
            { name: 'Max Health', icon: 'â¤ï¸', desc: '+25 max HP', stat: 'maxHealth', add: 25 },
            { name: 'XP Magnet', icon: 'ðŸ§²', desc: '+30% pickup range', stat: 'pickupRange', mult: 1.3 },
            { name: 'XP Boost', icon: 'âœ¨', desc: '+20% XP gain', stat: 'xpMultiplier', mult: 1.2 },
            { name: 'Bullet Speed', icon: 'ðŸ’¨', desc: '+25% projectile speed', stat: 'projectileSpeed', mult: 1.25 }
        ];

        // ============================================================================
        // PULSE ADAPTIVE MUSIC SYSTEM - Generic, Data-Driven, Diegetic
        // Automatically adapts to changes in ARENA_CONFIG, ENEMY_TYPES, BOSS_CONFIG
        // ============================================================================
        
        const PulseMusic = {
            // Audio context and nodes
            ctx: null,
            masterGain: null,
            musicBus: null,
            sfxBus: null,
            compressor: null,
            
            // State
            initialized: false,
            enabled: true,
            currentArenaId: null,
            currentProfile: null,
            activeOscillators: [],
            activeLayers: {},
            scheduledEvents: [],
            
            // Timing
            bpm: 120,
            beatDuration: 0.5,
            barDuration: 2,
            lastBeat: 0,
            beatCount: 0,
            nextBarTime: 0,
            
            // Adaptive state
            intensity: 0,
            targetIntensity: 0,
            filterCutoff: 8000,
            targetFilterCutoff: 8000,
            harmonicTension: 0,
            bossPhase: 0,
            
            // Hysteresis
            lastLayerChange: 0,
            lastIntensityChange: 0,
            
            // Musical scales (intervals from root)
            SCALES: {
                dorian: [0, 2, 3, 5, 7, 9, 10],
                phrygian: [0, 1, 3, 5, 7, 8, 10],
                lydian: [0, 2, 4, 6, 7, 9, 11],
                mixolydian: [0, 2, 4, 5, 7, 9, 10],
                locrian: [0, 1, 3, 5, 6, 8, 10],
                minor: [0, 2, 3, 5, 7, 8, 10],
                major: [0, 2, 4, 5, 7, 9, 11],
                chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
            },
            
            // Root notes (MIDI note numbers, octave 3)
            ROOTS: { 'C': 48, 'C#': 49, 'D': 50, 'D#': 51, 'E': 52, 'F': 53, 'F#': 54, 'G': 55, 'G#': 56, 'A': 57, 'A#': 58, 'B': 59 },
            
            // Leitmotif: The Pulse (relative intervals)
            LEITMOTIF: [0, 3, 5, 7], // Minor 3rd up, Major 2nd up, Major 2nd up
            LEITMOTIF_RHYTHM: [1, 1, 1.5, 0.5], // Beat durations
            
            // ============================================================================
            // INITIALIZATION
            // ============================================================================
            
            init() {
                if (this.initialized) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Master chain
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.6;
                    
                    this.compressor = this.ctx.createDynamicsCompressor();
                    this.compressor.threshold.value = -24;
                    this.compressor.knee.value = 30;
                    this.compressor.ratio.value = 4;
                    this.compressor.attack.value = 0.003;
                    this.compressor.release.value = 0.25;
                    
                    // Music bus with filter
                    this.musicBus = this.ctx.createGain();
                    this.musicBus.gain.value = 0.7;
                    this.musicFilter = this.ctx.createBiquadFilter();
                    this.musicFilter.type = 'lowpass';
                    this.musicFilter.frequency.value = 8000;
                    this.musicFilter.Q.value = 1;
                    
                    // SFX bus
                    this.sfxBus = this.ctx.createGain();
                    this.sfxBus.gain.value = 0.5;
                    
                    // Connect chain
                    this.musicBus.connect(this.musicFilter);
                    this.musicFilter.connect(this.masterGain);
                    this.sfxBus.connect(this.masterGain);
                    this.masterGain.connect(this.compressor);
                    this.compressor.connect(this.ctx.destination);
                    
                    // Generate profiles from game config
                    this.generateAllProfiles();
                    
                    this.initialized = true;
                    console.log('[PulseMusic] Initialized with', Object.keys(this.arenaProfiles).length, 'arena profiles');
                } catch (e) {
                    console.warn('[PulseMusic] Web Audio not available:', e);
                    this.enabled = false;
                }
            },
            
            // Resume audio context (required after user interaction)
            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            
            // ============================================================================
            // PROFILE GENERATION - Reads from game config automatically
            // ============================================================================
            
            arenaProfiles: {},
            enemySfxProfiles: {},
            bossProfiles: {},
            
            generateAllProfiles() {
                // Generate arena profiles from ARENA_CONFIG
                const arenaIds = Object.keys(ARENA_CONFIG.arenas);
                arenaIds.forEach((id, index) => {
                    this.arenaProfiles[id] = this.generateArenaProfile(parseInt(id), ARENA_CONFIG.arenas[id], index, arenaIds.length);
                });
                
                // Generate enemy SFX profiles from ENEMY_TYPES
                Object.keys(ENEMY_TYPES).forEach((typeName, index) => {
                    this.enemySfxProfiles[typeName] = this.generateEnemySfxProfile(typeName, ENEMY_TYPES[typeName], index);
                });
                
                // Generate boss profiles from BOSS_CONFIG
                Object.keys(BOSS_CONFIG).forEach((id, index) => {
                    this.bossProfiles[id] = this.generateBossProfile(parseInt(id), BOSS_CONFIG[id], index);
                });
            },
            
            // Hash function for deterministic generation
            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash);
            },
            
            // Generate arena music profile from config
            generateArenaProfile(arenaId, arenaData, index, totalArenas) {
                const hash = this.hashString(arenaData.name + JSON.stringify(arenaData.features));
                const scaleKeys = Object.keys(this.SCALES);
                const rootKeys = Object.keys(this.ROOTS);
                
                // Deterministic selection based on hash
                const rootNote = rootKeys[hash % rootKeys.length];
                const scale = scaleKeys[(hash >> 4) % scaleKeys.length];
                
                // Tempo increases with arena progression
                const baseTempo = 115 + (index * 4) + (hash % 10);
                
                // Color-derived characteristics
                const r = (arenaData.color >> 16) & 0xFF;
                const g = (arenaData.color >> 8) & 0xFF;
                const b = arenaData.color & 0xFF;
                const brightness = (r + g + b) / 3;
                
                // Feature-based musical characteristics
                const hasVerticality = arenaData.features.includes('vertical');
                const hasTunnels = arenaData.features.includes('tunnels');
                const hasHazards = arenaData.features.includes('hazards');
                const complexity = arenaData.features.length;
                
                return {
                    arenaId,
                    name: arenaData.name,
                    
                    // Tonality
                    rootNote,
                    rootMidi: this.ROOTS[rootNote],
                    scale,
                    scaleIntervals: this.SCALES[scale],
                    
                    // Tempo
                    baseTempo,
                    tempoRange: [baseTempo - 3, baseTempo + 5],
                    
                    // Timbre characteristics (0-1)
                    brightness: brightness / 255,
                    warmth: r / 255,
                    tension: hasHazards ? 0.8 : (hasTunnels ? 0.6 : 0.3),
                    depth: hasVerticality ? 0.7 : 0.4,
                    
                    // Layer configuration
                    maxLayers: 3 + Math.floor(complexity / 2),
                    layerThresholds: this.generateLayerThresholds(complexity),
                    
                    // Leitmotif variation
                    leitmotifOctave: hasVerticality ? 5 : 4,
                    leitmotifSpeed: hasTunnels ? 0.8 : 1.0,
                    
                    // Filter settings
                    baseFilterCutoff: 4000 + (brightness * 40),
                    filterResonance: hasTunnels ? 3 : 1,
                    
                    // Generated hash for consistency check
                    profileHash: hash
                };
            },
            
            generateLayerThresholds(complexity) {
                const thresholds = [];
                const baseEnemies = 3;
                for (let i = 0; i <= complexity + 2; i++) {
                    thresholds.push({
                        layer: i,
                        minEnemies: i * baseEnemies,
                        maxEnemies: (i + 1) * baseEnemies + 2
                    });
                }
                return thresholds;
            },
            
            // Generate enemy SFX profile from config
            generateEnemySfxProfile(typeName, enemyData, index) {
                const hash = this.hashString(typeName + enemyData.behavior);
                
                // Map behaviors to musical roles
                const behaviorRoles = {
                    'chase': { role: 'rhythmic', pitchRange: [0, 4], rhythmDiv: 4 },
                    'shooter': { role: 'melodic', pitchRange: [4, 8], rhythmDiv: 8 },
                    'bouncer': { role: 'syncopation', pitchRange: [7, 11], rhythmDiv: 16 },
                    'shieldBreaker': { role: 'accent', pitchRange: [0, 2], rhythmDiv: 2 },
                    'waterBalloon': { role: 'pad', pitchRange: [0, 7], rhythmDiv: 1 },
                    'teleporter': { role: 'glitch', pitchRange: [5, 11], rhythmDiv: 32 }
                };
                
                const roleData = behaviorRoles[enemyData.behavior] || behaviorRoles['chase'];
                
                // Color-derived pitch offset
                const r = (enemyData.color >> 16) & 0xFF;
                const g = (enemyData.color >> 8) & 0xFF;
                const colorPitch = Math.floor((r + g) / 50);
                
                return {
                    typeName,
                    behavior: enemyData.behavior,
                    
                    // Musical role
                    role: roleData.role,
                    pitchClass: (hash % 12),
                    pitchRange: roleData.pitchRange,
                    rhythmDivision: roleData.rhythmDiv,
                    
                    // Volume and spatial
                    baseVolume: enemyData.damage > 15 ? 0.8 : 0.5,
                    spatialWidth: enemyData.speed > 0.05 ? 0.8 : 0.4,
                    
                    // Timbre
                    waveform: enemyData.damageReduction ? 'square' : (enemyData.speed > 0.08 ? 'sawtooth' : 'triangle'),
                    attack: enemyData.behavior === 'shieldBreaker' ? 0.01 : 0.05,
                    release: enemyData.behavior === 'waterBalloon' ? 0.5 : 0.15,
                    
                    // Is this an elite-type enemy?
                    isElite: enemyData.spawnWeight < 10,
                    
                    // Color pitch modifier
                    colorPitchMod: colorPitch
                };
            },
            
            // Generate boss music profile from config
            generateBossProfile(bossId, bossData, index) {
                const hash = this.hashString(bossData.name + bossData.ai);
                
                // AI-based musical characteristics
                const aiCharacteristics = {
                    'pillarGuardian': { intensity: 0.7, chaos: 0.3, melodic: true },
                    'slimeQueen': { intensity: 0.6, chaos: 0.5, melodic: false },
                    'teleportingTyrant': { intensity: 0.8, chaos: 0.7, melodic: true },
                    'balloonKing': { intensity: 0.5, chaos: 0.4, melodic: false },
                    'tunnelWyrm': { intensity: 0.9, chaos: 0.6, melodic: false },
                    'chaosIncarnate': { intensity: 1.0, chaos: 1.0, melodic: true }
                };
                
                const aiData = aiCharacteristics[bossData.ai] || { intensity: 0.7, chaos: 0.5, melodic: true };
                
                return {
                    bossId,
                    name: bossData.name,
                    ai: bossData.ai,
                    
                    // Intensity scaling
                    baseIntensity: aiData.intensity,
                    chaosLevel: aiData.chaos,
                    useMelody: aiData.melodic,
                    
                    // Phase configurations
                    phases: {
                        1: { tempoMult: 1.0, layerMult: 1.0, filterMod: 0 },
                        2: { tempoMult: 1.05, layerMult: 1.3, filterMod: 1000 },
                        3: { tempoMult: 1.12, layerMult: 1.6, filterMod: 3000 }
                    },
                    
                    // Size affects sub-bass prominence
                    bassBoost: bossData.size / 4,
                    
                    // Color for visual sync
                    color: bossData.color
                };
            },
            
            // ============================================================================
            // MUSIC PLAYBACK
            // ============================================================================
            
            loadArena(arenaId) {
                if (!this.enabled || !this.initialized) return;
                
                // Get profile (generate if arena doesn't exist in config)
                let profile = this.arenaProfiles[arenaId];
                if (!profile) {
                    // Dynamic arena - generate profile on the fly
                    const arenaData = ARENA_CONFIG.arenas[arenaId];
                    if (arenaData) {
                        profile = this.generateArenaProfile(arenaId, arenaData, arenaId - 1, Object.keys(ARENA_CONFIG.arenas).length);
                        this.arenaProfiles[arenaId] = profile;
                    } else {
                        // Fallback to arena 1 profile
                        profile = this.arenaProfiles[1] || this.generateArenaProfile(1, { name: 'Unknown', features: ['flat'], color: 0x333333 }, 0, 1);
                    }
                }
                
                this.currentArenaId = arenaId;
                this.currentProfile = profile;
                this.bpm = profile.baseTempo;
                this.beatDuration = 60 / this.bpm;
                this.barDuration = this.beatDuration * 4;
                this.filterCutoff = profile.baseFilterCutoff;
                this.targetFilterCutoff = profile.baseFilterCutoff;
                
                console.log('[PulseMusic] Loaded arena', arenaId, profile.name, '- Key:', profile.rootNote, profile.scale, '- BPM:', this.bpm);
            },
            
            start() {
                if (!this.enabled || !this.initialized) return;
                this.resume();
                this.lastBeat = this.ctx.currentTime;
                this.nextBarTime = this.ctx.currentTime;
                this.beatCount = 0;
                this.startMusicLoop();
            },
            
            stop() {
                this.stopAllSounds();
                this.scheduledEvents = [];
            },
            
            stopAllSounds() {
                this.activeOscillators.forEach(osc => {
                    try {
                        osc.stop();
                        osc.disconnect();
                    } catch (e) {}
                });
                this.activeOscillators = [];
            },
            
            // ============================================================================
            // MUSIC GENERATION LOOP
            // ============================================================================
            
            startMusicLoop() {
                if (!this.enabled) return;
                this.musicLoopId = setInterval(() => this.musicTick(), 50);
            },
            
            stopMusicLoop() {
                if (this.musicLoopId) {
                    clearInterval(this.musicLoopId);
                    this.musicLoopId = null;
                }
            },
            
            musicTick() {
                if (!this.currentProfile || !this.ctx) return;
                
                const now = this.ctx.currentTime;
                
                // Schedule events for the next bar
                if (now >= this.nextBarTime - 0.1) {
                    this.scheduleBar(this.nextBarTime);
                    this.nextBarTime += this.barDuration;
                }
                
                // Smooth filter transitions
                this.filterCutoff += (this.targetFilterCutoff - this.filterCutoff) * 0.05;
                this.musicFilter.frequency.setValueAtTime(this.filterCutoff, now);
                
                // Smooth intensity transitions
                this.intensity += (this.targetIntensity - this.intensity) * 0.03;
                
                // Clean up finished oscillators
                this.activeOscillators = this.activeOscillators.filter(osc => {
                    try {
                        return osc.context.currentTime < osc.endTime;
                    } catch (e) {
                        return false;
                    }
                });
            },
            
            scheduleBar(barStartTime) {
                const profile = this.currentProfile;
                if (!profile) return;
                
                // Base layer: kick drum pattern
                this.scheduleKickPattern(barStartTime, profile);
                
                // Bass layer (always on, follows intensity)
                if (this.intensity > 0.1) {
                    this.scheduleBassline(barStartTime, profile);
                }
                
                // Harmonic layer (wave 3+)
                if (this.intensity > 0.3) {
                    this.scheduleChords(barStartTime, profile);
                }
                
                // Melodic layer (wave 5+)
                if (this.intensity > 0.5) {
                    this.scheduleMelody(barStartTime, profile);
                }
                
                // High intensity layer (wave 7+ or boss)
                if (this.intensity > 0.7 || this.bossPhase > 0) {
                    this.scheduleArpeggio(barStartTime, profile);
                }
                
                // Boss-specific layers
                if (this.bossPhase > 0) {
                    this.scheduleBossLayer(barStartTime, profile);
                }
            },
            
            // ============================================================================
            // MUSICAL ELEMENT GENERATORS
            // ============================================================================
            
            scheduleKickPattern(startTime, profile) {
                const kickTimes = [0, 1, 2, 3]; // 4-on-the-floor
                kickTimes.forEach(beat => {
                    const time = startTime + (beat * this.beatDuration);
                    this.playDrum('kick', time, profile);
                });
                
                // Snare on 2 and 4
                if (this.intensity > 0.2) {
                    [1, 3].forEach(beat => {
                        const time = startTime + (beat * this.beatDuration);
                        this.playDrum('snare', time, profile);
                    });
                }
                
                // Hi-hats based on intensity
                if (this.intensity > 0.4) {
                    for (let i = 0; i < 8; i++) {
                        const time = startTime + (i * this.beatDuration / 2);
                        this.playDrum('hihat', time, profile, i % 2 === 0 ? 0.4 : 0.2);
                    }
                }
            },
            
            scheduleBassline(startTime, profile) {
                const root = profile.rootMidi;
                const scale = profile.scaleIntervals;
                
                // Simple bass pattern following root and 5th
                const bassNotes = [0, 0, 4, 4]; // Root, root, 5th, 5th (scale degrees)
                bassNotes.forEach((degree, i) => {
                    const time = startTime + (i * this.beatDuration);
                    const note = root - 12 + scale[degree % scale.length];
                    this.playBass(note, time, this.beatDuration * 0.9, profile);
                });
            },
            
            scheduleChords(startTime, profile) {
                const root = profile.rootMidi;
                const scale = profile.scaleIntervals;
                
                // Build chord from scale
                const chordDegrees = [0, 2, 4]; // 1-3-5
                const tension = this.harmonicTension;
                if (tension > 0.5) chordDegrees.push(6); // Add 7th
                
                const chordNotes = chordDegrees.map(d => root + scale[d % scale.length]);
                
                // Play chord as pad
                this.playChord(chordNotes, startTime, this.barDuration * 0.95, profile);
            },
            
            scheduleMelody(startTime, profile) {
                const root = profile.rootMidi + 12; // Octave up
                const scale = profile.scaleIntervals;
                
                // Use leitmotif with variation based on beat count
                const variation = (this.beatCount / 4) % 4;
                const motif = [...this.LEITMOTIF];
                
                // Vary the motif
                if (variation === 1) motif.reverse();
                if (variation === 2) motif[2] += 2;
                if (variation === 3) motif[0] += 5;
                
                let time = startTime;
                motif.forEach((interval, i) => {
                    const duration = this.LEITMOTIF_RHYTHM[i] * this.beatDuration * profile.leitmotifSpeed;
                    const scaleDegree = interval % scale.length;
                    const note = root + scale[scaleDegree] + Math.floor(interval / scale.length) * 12;
                    
                    this.playLead(note, time, duration * 0.8, profile);
                    time += duration;
                });
            },
            
            scheduleArpeggio(startTime, profile) {
                const root = profile.rootMidi + 12;
                const scale = profile.scaleIntervals;
                const arpPattern = [0, 2, 4, 2]; // Up and down
                
                const noteDuration = this.beatDuration / 4;
                for (let i = 0; i < 16; i++) {
                    const time = startTime + (i * noteDuration);
                    const degree = arpPattern[i % arpPattern.length] + Math.floor(i / 4);
                    const note = root + scale[degree % scale.length] + Math.floor(degree / scale.length) * 12;
                    this.playArp(note, time, noteDuration * 0.7, profile);
                }
            },
            
            scheduleBossLayer(startTime, profile) {
                // Sub-bass drone
                const bossProfile = this.bossProfiles[this.currentArenaId];
                if (!bossProfile) return;
                
                const subNote = profile.rootMidi - 24; // Two octaves down
                this.playSubBass(subNote, startTime, this.barDuration, profile, bossProfile.bassBoost);
                
                // Phase-specific additions
                if (this.bossPhase >= 2) {
                    // Add tension stabs
                    [0.5, 2.5].forEach(beat => {
                        const time = startTime + (beat * this.beatDuration);
                        this.playStab(profile.rootMidi + profile.scaleIntervals[5], time, profile);
                    });
                }
                
                if (this.bossPhase >= 3) {
                    // Chaotic fills
                    for (let i = 0; i < 4; i++) {
                        const time = startTime + (Math.random() * this.barDuration);
                        const note = profile.rootMidi + profile.scaleIntervals[Math.floor(Math.random() * profile.scaleIntervals.length)];
                        this.playGlitch(note, time, 0.1, profile);
                    }
                }
            },
            
            // ============================================================================
            // SOUND GENERATORS
            // ============================================================================
            
            midiToFreq(midi) {
                return 440 * Math.pow(2, (midi - 69) / 12);
            },
            
            playDrum(type, time, profile, volumeMod = 1) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                if (type === 'kick') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, time);
                    osc.frequency.exponentialRampToValueAtTime(40, time + 0.1);
                    gain.gain.setValueAtTime(0.8 * volumeMod, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                } else if (type === 'snare') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(200, time);
                    gain.gain.setValueAtTime(0.4 * volumeMod, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                } else if (type === 'hihat') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(8000, time);
                    gain.gain.setValueAtTime(0.1 * volumeMod, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                }
                
                osc.connect(gain);
                gain.connect(this.musicBus);
                osc.start(time);
                osc.stop(time + 0.5);
                osc.endTime = time + 0.5;
                this.activeOscillators.push(osc);
            },
            
            playBass(note, time, duration, profile) {
                const freq = this.midiToFreq(note);
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, time);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800 + (profile.warmth * 400), time);
                
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.35 * this.intensity, time + 0.02);
                gain.gain.setValueAtTime(0.3 * this.intensity, time + duration * 0.8);
                gain.gain.linearRampToValueAtTime(0, time + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.musicBus);
                osc.start(time);
                osc.stop(time + duration + 0.1);
                osc.endTime = time + duration + 0.1;
                this.activeOscillators.push(osc);
            },
            
            playChord(notes, time, duration, profile) {
                notes.forEach((note, i) => {
                    const freq = this.midiToFreq(note);
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(freq, time);
                    
                    // Slight detune for width
                    osc.detune.setValueAtTime((i - 1) * 5, time);
                    
                    const vol = 0.12 * this.intensity * (1 - this.harmonicTension * 0.3);
                    gain.gain.setValueAtTime(0, time);
                    gain.gain.linearRampToValueAtTime(vol, time + 0.2);
                    gain.gain.setValueAtTime(vol * 0.8, time + duration * 0.8);
                    gain.gain.linearRampToValueAtTime(0, time + duration);
                    
                    osc.connect(gain);
                    gain.connect(this.musicBus);
                    osc.start(time);
                    osc.stop(time + duration + 0.1);
                    osc.endTime = time + duration + 0.1;
                    this.activeOscillators.push(osc);
                });
            },
            
            playLead(note, time, duration, profile) {
                const freq = this.midiToFreq(note);
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = profile.brightness > 0.5 ? 'square' : 'triangle';
                osc.frequency.setValueAtTime(freq, time);
                
                const vol = 0.18 * this.intensity;
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(vol, time + 0.02);
                gain.gain.setValueAtTime(vol * 0.7, time + duration * 0.5);
                gain.gain.linearRampToValueAtTime(0, time + duration);
                
                osc.connect(gain);
                gain.connect(this.musicBus);
                osc.start(time);
                osc.stop(time + duration + 0.1);
                osc.endTime = time + duration + 0.1;
                this.activeOscillators.push(osc);
            },
            
            playArp(note, time, duration, profile) {
                const freq = this.midiToFreq(note);
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, time);
                
                const vol = 0.08 * this.intensity;
                gain.gain.setValueAtTime(vol, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
                
                osc.connect(gain);
                gain.connect(this.musicBus);
                osc.start(time);
                osc.stop(time + duration + 0.05);
                osc.endTime = time + duration + 0.05;
                this.activeOscillators.push(osc);
            },
            
            playSubBass(note, time, duration, profile, boost = 1) {
                const freq = this.midiToFreq(note);
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, time);
                
                gain.gain.setValueAtTime(0.4 * boost, time);
                gain.gain.setValueAtTime(0.35 * boost, time + duration * 0.9);
                gain.gain.linearRampToValueAtTime(0.3 * boost, time + duration);
                
                osc.connect(gain);
                gain.connect(this.musicBus);
                osc.start(time);
                osc.stop(time + duration + 0.1);
                osc.endTime = time + duration + 0.1;
                this.activeOscillators.push(osc);
            },
            
            playStab(note, time, profile) {
                const freq = this.midiToFreq(note);
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, time);
                
                gain.gain.setValueAtTime(0.3, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                
                osc.connect(gain);
                gain.connect(this.musicBus);
                osc.start(time);
                osc.stop(time + 0.2);
                osc.endTime = time + 0.2;
                this.activeOscillators.push(osc);
            },
            
            playGlitch(note, time, duration, profile) {
                const freq = this.midiToFreq(note);
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, time);
                osc.frequency.setValueAtTime(freq * 1.5, time + duration * 0.3);
                osc.frequency.setValueAtTime(freq * 0.5, time + duration * 0.6);
                
                gain.gain.setValueAtTime(0.15, time);
                gain.gain.setValueAtTime(0, time + duration);
                
                osc.connect(gain);
                gain.connect(this.musicBus);
                osc.start(time);
                osc.stop(time + duration + 0.05);
                osc.endTime = time + duration + 0.05;
                this.activeOscillators.push(osc);
            },
            
            // ============================================================================
            // ENEMY SFX - Integrated with music
            // ============================================================================
            
            playEnemySound(enemy, eventType) {
                if (!this.enabled || !this.initialized || !this.currentProfile) return;
                
                const typeName = enemy.enemyType || 'grunt';
                let sfxProfile = this.enemySfxProfiles[typeName];
                
                // Generate profile on-the-fly if enemy type is new
                if (!sfxProfile && ENEMY_TYPES[typeName]) {
                    sfxProfile = this.generateEnemySfxProfile(typeName, ENEMY_TYPES[typeName], Object.keys(this.enemySfxProfiles).length);
                    this.enemySfxProfiles[typeName] = sfxProfile;
                }
                
                if (!sfxProfile) sfxProfile = this.enemySfxProfiles['grunt'] || { pitchClass: 0, baseVolume: 0.3, waveform: 'triangle', attack: 0.05, release: 0.15 };
                
                const profile = this.currentProfile;
                const now = this.ctx.currentTime;
                
                // Quantize to next 16th note for rhythmic integration
                const quantize = this.beatDuration / 4;
                const quantizedTime = Math.ceil(now / quantize) * quantize;
                
                // Calculate pitch from scale
                const scaleDegree = sfxProfile.pitchClass % profile.scaleIntervals.length;
                const octaveOffset = eventType === 'death' ? 12 : (eventType === 'spawn' ? -12 : 0);
                const note = profile.rootMidi + profile.scaleIntervals[scaleDegree] + octaveOffset + sfxProfile.colorPitchMod;
                const freq = this.midiToFreq(note);
                
                // Create sound
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = sfxProfile.waveform;
                osc.frequency.setValueAtTime(freq, quantizedTime);
                
                // Event-specific modifications
                let volume = sfxProfile.baseVolume * 0.5;
                let duration = 0.15;
                
                if (eventType === 'death') {
                    // Death: pitch bend down, longer release
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.5, quantizedTime + 0.2);
                    duration = 0.3;
                    volume *= 1.5;
                } else if (eventType === 'spawn') {
                    // Spawn: pitch bend up
                    osc.frequency.setValueAtTime(freq * 0.7, quantizedTime);
                    osc.frequency.exponentialRampToValueAtTime(freq, quantizedTime + 0.1);
                    duration = 0.15;
                } else if (eventType === 'attack') {
                    // Attack: sharp transient
                    duration = 0.1;
                    volume *= 1.2;
                }
                
                gain.gain.setValueAtTime(0, quantizedTime);
                gain.gain.linearRampToValueAtTime(volume, quantizedTime + sfxProfile.attack);
                gain.gain.exponentialRampToValueAtTime(0.01, quantizedTime + duration);
                
                osc.connect(gain);
                gain.connect(this.sfxBus);
                osc.start(quantizedTime);
                osc.stop(quantizedTime + duration + 0.1);
                osc.endTime = quantizedTime + duration + 0.1;
                this.activeOscillators.push(osc);
            },
            
            // ============================================================================
            // STINGERS AND ONE-SHOTS
            // ============================================================================
            
            playWaveStinger() {
                if (!this.enabled || !this.initialized || !this.currentProfile) return;
                
                const profile = this.currentProfile;
                const now = this.ctx.currentTime;
                
                // Play ascending leitmotif
                let time = now;
                this.LEITMOTIF.forEach((interval, i) => {
                    const note = profile.rootMidi + 12 + profile.scaleIntervals[interval % profile.scaleIntervals.length];
                    this.playLead(note, time, 0.15, profile);
                    time += 0.12;
                });
            },
            
            playBossStinger() {
                if (!this.enabled || !this.initialized || !this.currentProfile) return;
                
                const profile = this.currentProfile;
                const now = this.ctx.currentTime;
                
                // Dramatic descending phrase
                const notes = [7, 5, 3, 0].map(d => profile.rootMidi + profile.scaleIntervals[d % profile.scaleIntervals.length]);
                
                let time = now;
                notes.forEach((note, i) => {
                    this.playStab(note, time, profile);
                    time += 0.2;
                });
                
                // Sub impact
                this.playSubBass(profile.rootMidi - 24, now + 0.8, 1.5, profile, 1.5);
            },
            
            playVictoryStinger() {
                if (!this.enabled || !this.initialized || !this.currentProfile) return;
                
                const profile = this.currentProfile;
                const now = this.ctx.currentTime;
                
                // Triumphant ascending phrase
                const majorScale = [0, 2, 4, 5, 7, 9, 11];
                const notes = [0, 2, 4, 7].map(d => profile.rootMidi + 12 + majorScale[d % majorScale.length]);
                
                let time = now;
                notes.forEach((note, i) => {
                    this.playLead(note, time, 0.25, profile);
                    time += 0.15;
                });
                
                // Final chord
                const chord = [0, 4, 7].map(d => profile.rootMidi + majorScale[d]);
                this.playChord(chord, now + 0.6, 1.5, profile);
            },
            
            playDamageStinger(healthPercent) {
                if (!this.enabled || !this.initialized || !this.currentProfile) return;
                
                const profile = this.currentProfile;
                const now = this.ctx.currentTime;
                
                // Dissonant hit
                const note = profile.rootMidi + 6; // Tritone
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(this.midiToFreq(note), now);
                osc.frequency.exponentialRampToValueAtTime(this.midiToFreq(note - 12), now + 0.2);
                
                const vol = 0.3 * (1 - healthPercent); // Louder at low health
                gain.gain.setValueAtTime(vol, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                
                osc.connect(gain);
                gain.connect(this.sfxBus);
                osc.start(now);
                osc.stop(now + 0.25);
                osc.endTime = now + 0.25;
                this.activeOscillators.push(osc);
            },
            
            playLevelUpStinger() {
                if (!this.enabled || !this.initialized || !this.currentProfile) return;
                
                const profile = this.currentProfile;
                const now = this.ctx.currentTime;
                
                // Bright ascending arpeggio
                const notes = [0, 4, 7, 12].map(interval => profile.rootMidi + 12 + profile.scaleIntervals[interval % profile.scaleIntervals.length] + Math.floor(interval / profile.scaleIntervals.length) * 12);
                
                let time = now;
                notes.forEach((note, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(this.midiToFreq(note), time);
                    
                    gain.gain.setValueAtTime(0.25, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                    
                    osc.connect(gain);
                    gain.connect(this.sfxBus);
                    osc.start(time);
                    osc.stop(time + 0.35);
                    osc.endTime = time + 0.35;
                    this.activeOscillators.push(osc);
                    
                    time += 0.08;
                });
            },
            
            // ============================================================================
            // ADAPTIVE STATE UPDATES
            // ============================================================================
            
            update(gameStateRef, enemiesRef, bossRef) {
                if (!this.enabled || !this.initialized) return;
                
                const now = Date.now();
                
                // Calculate target intensity from enemy count
                const enemyCount = enemiesRef.length;
                const maxEnemiesForIntensity = 20;
                let enemyIntensity = Math.min(1, enemyCount / maxEnemiesForIntensity);
                
                // Wave progress adds base intensity
                const wavesTotal = ARENA_CONFIG.wavesPerArena || 10;
                const waveIntensity = (gameStateRef.currentWave - 1) / wavesTotal;
                
                // Combine intensities
                this.targetIntensity = Math.min(1, (enemyIntensity * 0.6) + (waveIntensity * 0.4));
                
                // Boss active overrides
                if (bossRef && gameStateRef.bossActive) {
                    this.targetIntensity = 0.9;
                    
                    // Calculate boss phase
                    const healthPercent = bossRef.health / bossRef.maxHealth;
                    if (healthPercent < 0.33) this.bossPhase = 3;
                    else if (healthPercent < 0.66) this.bossPhase = 2;
                    else this.bossPhase = 1;
                } else {
                    this.bossPhase = 0;
                }
                
                // Health affects filter (low health = muffled/tense)
                const healthPercent = gameStateRef.health / gameStateRef.maxHealth;
                if (this.currentProfile) {
                    const baseFilter = this.currentProfile.baseFilterCutoff;
                    this.targetFilterCutoff = baseFilter * (0.3 + healthPercent * 0.7);
                    
                    // Boss phase opens filter more
                    if (this.bossPhase > 0) {
                        const bossProfile = this.bossProfiles[this.currentArenaId];
                        if (bossProfile) {
                            this.targetFilterCutoff += bossProfile.phases[this.bossPhase].filterMod;
                        }
                    }
                }
                
                // Harmonic tension increases through waves
                this.harmonicTension = waveIntensity * 0.7 + (this.bossPhase > 0 ? 0.3 : 0);
                
                // Update beat counter
                this.beatCount++;
            },
            
            // ============================================================================
            // EVENT HANDLERS - Called by game code
            // ============================================================================
            
            onArenaChange(arenaId) {
                this.loadArena(arenaId);
            },
            
            onWaveStart(waveNum) {
                this.playWaveStinger();
            },
            
            onWaveClear() {
                // Brief musical resolution
                if (this.currentProfile) {
                    const now = this.ctx.currentTime;
                    const chord = [0, 4, 7].map(d => this.currentProfile.rootMidi + this.currentProfile.scaleIntervals[d % this.currentProfile.scaleIntervals.length]);
                    this.playChord(chord, now, 0.8, this.currentProfile);
                }
            },
            
            onBossStart(arenaId) {
                this.bossPhase = 1;
                this.playBossStinger();
            },
            
            onBossPhaseChange(phase) {
                this.bossPhase = phase;
                // Musical transition for phase change
                if (this.currentProfile) {
                    this.playStab(this.currentProfile.rootMidi + 12, this.ctx.currentTime, this.currentProfile);
                }
            },
            
            onBossDefeat() {
                this.bossPhase = 0;
                this.playVictoryStinger();
            },
            
            onEnemySpawn(enemy) {
                this.playEnemySound(enemy, 'spawn');
            },
            
            onEnemyDeath(enemy) {
                this.playEnemySound(enemy, 'death');
            },
            
            onEnemyAttack(enemy) {
                this.playEnemySound(enemy, 'attack');
            },
            
            onPlayerDamage(healthPercent) {
                this.playDamageStinger(healthPercent);
            },
            
            onLevelUp() {
                this.playLevelUpStinger();
            },
            
            onGameOver() {
                this.stopMusicLoop();
                // Sad descending phrase
                if (this.currentProfile && this.ctx) {
                    const now = this.ctx.currentTime;
                    const notes = [7, 5, 3, 0].map(d => this.currentProfile.rootMidi + this.currentProfile.scaleIntervals[d % this.currentProfile.scaleIntervals.length]);
                    let time = now;
                    notes.forEach(note => {
                        this.playLead(note, time, 0.5, this.currentProfile);
                        time += 0.4;
                    });
                }
            },
            
            // ============================================================================
            // UTILITY
            // ============================================================================
            
            setMasterVolume(vol) {
                if (this.masterGain) {
                    this.masterGain.gain.setValueAtTime(Math.max(0, Math.min(1, vol)), this.ctx.currentTime);
                }
            },
            
            setEnabled(enabled) {
                this.enabled = enabled;
                if (!enabled) {
                    this.stop();
                }
            }
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 20, 80);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            scene.add(new THREE.PointLight(0xff6644, 0.5, 30).translateX(-20).translateY(5).translateZ(-20));
            scene.add(new THREE.PointLight(0x4466ff, 0.5, 30).translateX(20).translateY(5).translateZ(20));

            createGround();
            createPlayer();
            initTrailPool();

            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                // M key toggles music
                if (e.code === 'KeyM') {
                    PulseMusic.setEnabled(!PulseMusic.enabled);
                    if (PulseMusic.enabled && gameState.running) {
                        PulseMusic.resume();
                        PulseMusic.start();
                    }
                    console.log('[PulseMusic] Music', PulseMusic.enabled ? 'enabled' : 'disabled');
                }
            });
            document.addEventListener('keyup', (e) => keys[e.code] = false);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', () => { if (gameState.running && !isPointerLocked) renderer.domElement.requestPointerLock(); });
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
                const pauseIndicator = document.getElementById('pause-indicator');
                const upgradeMenu = document.getElementById('upgrade-menu');
                const gameOverScreen = document.getElementById('game-over');
                if (gameState.running && upgradeMenu.style.display !== 'block' && gameOverScreen.style.display !== 'block') {
                    gameState.paused = !isPointerLocked;
                    pauseIndicator.style.display = isPointerLocked ? 'none' : 'block';
                }
            });
            window.addEventListener('resize', onWindowResize);
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            
            // Initialize PULSE Music System
            PulseMusic.init();
            
            renderer.render(scene, camera);
        }

        // Arena Generation (Progressive)
        function generateArena(arenaNumber) {
            clearArenaGeometry();
            const arenaNum = Math.min(arenaNumber, 6);
            const arenaData = ARENA_CONFIG.arenas[arenaNum];
            createBoundaryWalls();
            if (arenaData.features.includes('pillars')) addPillars(arenaNum);
            if (arenaData.features.includes('vertical')) addVerticalElements(arenaNum);
            if (arenaData.features.includes('platforms')) addPlatforms(arenaNum);
            if (arenaData.features.includes('tunnels')) addTunnelWalls(arenaNum);
            if (arenaData.features.includes('hazards')) addHazardZones(arenaNum);
            if (ground && ground.material) ground.material.color.setHex(arenaData.color);
        }
        
        function clearArenaGeometry() {
            obstacles.forEach(obs => { if (obs.geometry) obs.geometry.dispose(); if (obs.material) obs.material.dispose(); scene.remove(obs); });
            obstacles = [];
            arenaWalls.forEach(wall => { if (wall.geometry) wall.geometry.dispose(); if (wall.material) wall.material.dispose(); scene.remove(wall); });
            arenaWalls = [];
            hazardZones.forEach(hz => { if (hz.geometry) hz.geometry.dispose(); if (hz.material) hz.material.dispose(); scene.remove(hz); });
            hazardZones = [];
        }
        
        function addPillars(arenaNum) {
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x5a5a7a, roughness: 0.6 });
            const count = 4 + arenaNum * 2, radius = 18;
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                createObstacle(Math.cos(angle) * radius, Math.sin(angle) * radius, 2, 3 + arenaNum * 0.5, 2, pillarMat);
            }
            const coverMat = new THREE.MeshStandardMaterial({ color: 0x4a4a6a, roughness: 0.7 });
            [[-10, -10], [10, -10], [-10, 10], [10, 10]].forEach(([x, z]) => createObstacle(x, z, 3, 1.2, 2, coverMat));
        }
        
        function addVerticalElements(arenaNum) {
            const platformMat = new THREE.MeshStandardMaterial({ color: 0x5a4a7a, roughness: 0.5 });
            createObstacle(0, 0, 8, 2, 8, platformMat);
            const rampMat = new THREE.MeshStandardMaterial({ color: 0x6a5a8a, roughness: 0.6 });
            createObstacle(6, 0, 3, 0.7, 3, rampMat);
            createObstacle(8, 0, 2.5, 1.3, 2.5, rampMat);
            createObstacle(-6, 0, 3, 0.7, 3, rampMat);
            createObstacle(-8, 0, 2.5, 1.3, 2.5, rampMat);
            createObstacle(0, 6, 3, 0.7, 3, rampMat);
            createObstacle(0, -6, 3, 0.7, 3, rampMat);
        }
        
        function addPlatforms(arenaNum) {
            const platformMat = new THREE.MeshStandardMaterial({ color: 0x4a6a5a, roughness: 0.5 });
            [{x:-22,z:-22,h:2.5},{x:22,z:-22,h:3},{x:-22,z:22,h:3.5},{x:22,z:22,h:4}].forEach(c => createObstacle(c.x, c.z, 7, c.h, 7, platformMat));
            const bridgeMat = new THREE.MeshStandardMaterial({ color: 0x5a7a6a, roughness: 0.6 });
            createObstacle(-11, -11, 4, 1.2, 4, bridgeMat);
            createObstacle(11, 11, 4, 2, 4, bridgeMat);
        }
        
        function addTunnelWalls(arenaNum) {
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x6a4a5a, roughness: 0.7 });
            createObstacle(-28, 0, 12, 3.5, 3, wallMat);
            createObstacle(28, 0, 12, 3.5, 3, wallMat);
            createObstacle(0, -28, 3, 3.5, 12, wallMat);
            createObstacle(0, 28, 3, 3.5, 12, wallMat);
        }
        
        function addHazardZones(arenaNum) {
            [{x:-30,z:-30},{x:30,z:-30},{x:-30,z:30},{x:30,z:30}].forEach(pos => createHazardZone(pos.x, pos.z, 5, -1));
        }
        
        function createObstacle(x, z, sizeX, height, sizeZ, material) {
            const geometry = new THREE.BoxGeometry(sizeX, height, sizeZ);
            const obstacle = new THREE.Mesh(geometry, material);
            obstacle.position.set(x, height / 2, z);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            obstacle.collisionData = { minX: x - sizeX/2, maxX: x + sizeX/2, minZ: z - sizeZ/2, maxZ: z + sizeZ/2, height: height, topY: height };
            scene.add(obstacle);
            obstacles.push(obstacle);
            return obstacle;
        }
        
        function createHazardZone(x, z, radius, duration) {
            const geometry = new THREE.CircleGeometry(radius, 24);
            const material = new THREE.MeshBasicMaterial({ color: 0x44ff44, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
            const hazard = new THREE.Mesh(geometry, material);
            hazard.rotation.x = -Math.PI / 2;
            hazard.position.set(x, 0.05, z);
            hazard.radius = radius;
            hazard.duration = duration;
            hazard.damagePerFrame = 0.5;
            scene.add(hazard);
            hazardZones.push(hazard);
            return hazard;
        }
        
        function createBoundaryWalls() {
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x3a3a5a, transparent: true, opacity: 0.3 });
            const wallHeight = 8;
            for (let i = 0; i < 4; i++) {
                const wallGeom = new THREE.BoxGeometry(i < 2 ? 100 : 2, wallHeight, i < 2 ? 2 : 100);
                const wall = new THREE.Mesh(wallGeom, wallMat);
                wall.position.y = wallHeight / 2;
                if (i === 0) wall.position.z = -50;
                else if (i === 1) wall.position.z = 50;
                else if (i === 2) wall.position.x = -50;
                else wall.position.x = 50;
                scene.add(wall);
                arenaWalls.push(wall);
            }
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a4a, roughness: 0.8, metalness: 0.2 });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            const gridHelper = new THREE.GridHelper(100, 50, 0x444466, 0x333355);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
        }

        function createPlayer() {
            player = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x44aaff, emissive: 0x224488, emissiveIntensity: 0.3 });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.8, 16), bodyMat);
            body.castShadow = true;
            player.add(body);
            const top = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 8), bodyMat);
            top.position.y = 0.4;
            top.castShadow = true;
            player.add(top);
            const bottom = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 8), bodyMat);
            bottom.position.y = -0.4;
            bottom.castShadow = true;
            player.add(bottom);
            const glow = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), new THREE.MeshBasicMaterial({ color: 0x44aaff, transparent: true, opacity: 0.2 }));
            player.add(glow);
            player.position.y = 1;
            scene.add(player);
            player.bodyMaterial = bodyMat;
            player.velocity = new THREE.Vector3();
            player.isGrounded = true;
            player.bounceCount = 0;
            player.wasInAir = false;
            player.squashTime = 0;
        }
        
        // Enhanced Trail System
        function initTrailPool() {
            const trailGeom = new THREE.BoxGeometry(0.5, 0.08, 0.5);
            const trailMat = new THREE.MeshBasicMaterial({ color: 0x44ffff, transparent: true, opacity: 0 });
            for (let i = 0; i < TRAIL_MAX; i++) {
                const segment = new THREE.Mesh(trailGeom.clone(), trailMat.clone());
                segment.visible = false;
                segment.life = 0;
                scene.add(segment);
                trailPool.push(segment);
            }
        }
        
        function spawnTrail(position) {
            const segment = trailPool[trailIndex];
            segment.position.set(position.x, 0.05, position.z);
            segment.life = TRAIL_LIFETIME;
            segment.visible = true;
            segment.material.opacity = 0.85;
            segment.scale.set(1, 1, 1);
            trailIndex = (trailIndex + 1) % TRAIL_MAX;
        }
        
        function updateTrail() {
            for (const segment of trailPool) {
                if (segment.life > 0) {
                    segment.life--;
                    const t = segment.life / TRAIL_LIFETIME;
                    segment.material.opacity = t * 0.85;
                    segment.material.color.setRGB(0x44/255 * t, 0xff/255 * t, 1);
                    segment.scale.set(0.6 + t * 0.4, 0.5 + t * 0.5, 0.6 + t * 0.4);
                    if (segment.life <= 0) segment.visible = false;
                }
            }
        }

        // Wave System
        function updateWaveSystem() {
            switch (gameState.waveState) {
                case WAVE_STATE.WAVE_INTRO: handleWaveIntro(); break;
                case WAVE_STATE.WAVE_ACTIVE: handleWaveActive(); break;
                case WAVE_STATE.WAVE_CLEAR: handleWaveClear(); break;
                case WAVE_STATE.BOSS_INTRO: handleBossIntro(); break;
                case WAVE_STATE.BOSS_ACTIVE: handleBossActive(); break;
                case WAVE_STATE.BOSS_DEFEATED: handleBossDefeated(); break;
                case WAVE_STATE.ARENA_TRANSITION: handleArenaTransition(); break;
            }
        }
        
        function handleWaveIntro() {
            if (gameState.waveTimer === 0) {
                showWaveAnnouncement();
                PulseMusic.onWaveStart(gameState.currentWave);
            }
            gameState.waveTimer++;
            if (gameState.waveTimer > 120) {
                gameState.waveState = WAVE_STATE.WAVE_ACTIVE;
                gameState.waveTimer = 0;
                const base = 4 + gameState.currentArena * 2;
                const scaling = 1 + (gameState.currentWave - 1) * 0.25;
                gameState.enemiesToSpawn = Math.floor(base * scaling);
                gameState.waveEnemiesRemaining = gameState.enemiesToSpawn;
                gameState.lastWaveSpawn = 0;
                hideWaveAnnouncement();
            }
        }
        
        function handleWaveActive() {
            const now = Date.now();
            const spawnInterval = Math.max(350, 1400 - gameState.currentArena * 80 - gameState.currentWave * 40);
            if (gameState.enemiesToSpawn > 0 && now - gameState.lastWaveSpawn > spawnInterval) {
                spawnWaveEnemy();
                gameState.enemiesToSpawn--;
                gameState.lastWaveSpawn = now;
            }
            if (enemies.length === 0 && gameState.enemiesToSpawn === 0 && !currentBoss) {
                gameState.waveState = WAVE_STATE.WAVE_CLEAR;
                gameState.waveTimer = 0;
            }
        }
        
        function handleWaveClear() {
            if (gameState.waveTimer === 0) {
                PulseMusic.onWaveClear();
            }
            gameState.waveTimer++;
            if (gameState.waveTimer > 90) {
                if (gameState.currentWave >= WAVES_PER_ARENA) gameState.waveState = WAVE_STATE.BOSS_INTRO;
                else { gameState.currentWave++; gameState.waveState = WAVE_STATE.WAVE_INTRO; }
                gameState.waveTimer = 0;
                updateUI();
            }
        }
        
        function handleBossIntro() {
            if (gameState.waveTimer === 0) {
                showBossAnnouncement();
                PulseMusic.onBossStart(gameState.currentArena);
            }
            gameState.waveTimer++;
            if (gameState.waveTimer > 180) {
                spawnBoss(gameState.currentArena);
                gameState.bossActive = true;
                gameState.waveState = WAVE_STATE.BOSS_ACTIVE;
                gameState.waveTimer = 0;
                hideBossAnnouncement();
            }
        }
        
        function handleBossActive() {
            if (!currentBoss || !gameState.bossActive) { gameState.waveState = WAVE_STATE.BOSS_DEFEATED; gameState.waveTimer = 0; }
        }
        
        function handleBossDefeated() {
            if (gameState.waveTimer === 0) unlockArenaMechanics(gameState.currentArena);
            gameState.waveTimer++;
            if (gameState.waveTimer > 180) { gameState.waveState = WAVE_STATE.ARENA_TRANSITION; gameState.waveTimer = 0; }
        }
        
        function handleArenaTransition() {
            gameState.waveTimer++;
            if (gameState.waveTimer > 60) {
                gameState.currentArena++;
                gameState.currentWave = 1;
                generateArena(gameState.currentArena);
                player.position.set(0, 1, 0);
                player.velocity.set(0, 0, 0);
                gameState.waveState = WAVE_STATE.WAVE_INTRO;
                gameState.waveTimer = 0;
                
                // Load new arena music profile
                PulseMusic.onArenaChange(gameState.currentArena);
                
                updateUI();
            }
        }
        
        // Weighted Enemy Spawning
        function getWeightedEnemyType() {
            const availableTypes = [];
            let totalWeight = 0;
            for (const [typeName, typeData] of Object.entries(ENEMY_TYPES)) {
                if (typeData.minArena && gameState.currentArena < typeData.minArena) continue;
                availableTypes.push({ name: typeName, data: typeData });
                totalWeight += typeData.spawnWeight;
            }
            const waveBonus = gameState.currentWave * 0.05;
            let random = Math.random() * totalWeight;
            for (const type of availableTypes) {
                let weight = type.data.spawnWeight;
                if (type.data.spawnWeight < 10) weight += waveBonus * 10;
                random -= weight;
                if (random <= 0) return type;
            }
            return availableTypes[0];
        }
        
        function spawnWaveEnemy() {
            const distance = 28 + Math.random() * 12;
            const angle = Math.random() * Math.PI * 2;
            let x = Math.max(-42, Math.min(42, player.position.x + Math.cos(angle) * distance));
            let z = Math.max(-42, Math.min(42, player.position.z + Math.sin(angle) * distance));
            
            const enemyType = getWeightedEnemyType();
            const typeData = enemyType.data;
            const arenaScale = 1 + (gameState.currentArena - 1) * 0.15;
            const waveScale = 1 + (gameState.currentWave - 1) * 0.05;
            
            const geometry = new THREE.SphereGeometry(typeData.size, 12, 12);
            const material = new THREE.MeshStandardMaterial({ color: typeData.color, emissive: typeData.color, emissiveIntensity: 0.3 });
            const enemy = new THREE.Mesh(geometry, material);
            
            enemy.position.set(x, typeData.size, z);
            enemy.castShadow = true;
            enemy.health = Math.floor(typeData.health * arenaScale * waveScale);
            enemy.maxHealth = enemy.health;
            enemy.speed = typeData.speed * (1 + gameState.currentArena * 0.02);
            enemy.damage = Math.floor(typeData.damage * arenaScale);
            enemy.size = typeData.size;
            enemy.baseSize = typeData.size;
            enemy.isBoss = false;
            enemy.isElite = typeData.spawnWeight < 10;
            enemy.xpValue = typeData.xpValue;
            enemy.baseColor = typeData.color;
            enemy.velocityY = 0;
            enemy.velocity = new THREE.Vector3();
            enemy.enemyType = enemyType.name;
            enemy.behavior = typeData.behavior;
            enemy.damageReduction = typeData.damageReduction || 0;
            enemy.onDeath = typeData.onDeath || null;
            enemy.splitCount = typeData.splitCount || 0;
            
            if (typeData.behavior === 'shooter') { enemy.shootRange = typeData.shootRange; enemy.shootCooldown = typeData.shootCooldown; enemy.lastShot = 0; }
            if (typeData.behavior === 'bouncer') enemy.velocity.set((Math.random()-0.5)*enemy.speed*2, 0, (Math.random()-0.5)*enemy.speed*2);
            if (typeData.behavior === 'shieldBreaker') { enemy.rushRange = typeData.rushRange; enemy.rushSpeed = typeData.rushSpeed; enemy.isRushing = false; }
            if (typeData.behavior === 'waterBalloon') { enemy.growRate = typeData.growRate; enemy.maxSize = typeData.maxSize; enemy.explosionRadius = typeData.explosionRadius; }
            if (typeData.behavior === 'teleporter') { enemy.teleportCooldown = typeData.teleportCooldown; enemy.teleportRange = typeData.teleportRange; enemy.lastTeleport = 0; }
            
            scene.add(enemy);
            enemies.push(enemy);
            
            // Enemy spawn sound
            PulseMusic.onEnemySpawn(enemy);
        }
        
        function spawnSplitEnemy(position, parentSize) {
            const size = parentSize * 0.4;
            const enemy = new THREE.Mesh(new THREE.SphereGeometry(size, 8, 8), new THREE.MeshStandardMaterial({ color: 0xff66ff, emissive: 0xff44ff, emissiveIntensity: 0.3 }));
            const offset = new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2);
            enemy.position.copy(position).add(offset);
            enemy.position.y = size;
            enemy.castShadow = true;
            enemy.health = 5; enemy.maxHealth = 5; enemy.speed = 0.05; enemy.damage = 5;
            enemy.size = size; enemy.baseSize = size; enemy.isBoss = false; enemy.isElite = false;
            enemy.xpValue = 1; enemy.baseColor = 0xff66ff; enemy.velocityY = 0;
            enemy.velocity = new THREE.Vector3(); enemy.enemyType = 'splitling'; enemy.behavior = 'chase'; enemy.damageReduction = 0;
            scene.add(enemy);
            enemies.push(enemy);
        }

        // Boss System
        function spawnBoss(arenaNumber) {
            const config = BOSS_CONFIG[Math.min(arenaNumber, 6)];
            const boss = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: config.color, emissive: config.color, emissiveIntensity: 0.5 });
            const body = new THREE.Mesh(new THREE.SphereGeometry(config.size, 16, 16), bodyMat);
            body.castShadow = true;
            boss.add(body);
            boss.add(new THREE.Mesh(new THREE.SphereGeometry(config.size * 1.2, 16, 16), new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.3 })));
            const hornMat = new THREE.MeshStandardMaterial({ color: 0xffdd44 });
            for (let i = 0; i < 5; i++) {
                const horn = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.2, 8), hornMat);
                horn.position.set((i-2)*0.6, config.size+0.4, 0);
                horn.rotation.z = (i-2)*0.15;
                boss.add(horn);
            }
            boss.health = config.health + gameState.level * 25;
            boss.maxHealth = boss.health;
            boss.damage = config.damage;
            boss.size = config.size;
            boss.baseSize = config.size;
            boss.speed = 0.025;
            boss.isBoss = true;
            boss.isElite = false;
            boss.xpValue = 60 + arenaNumber * 15;
            boss.baseColor = config.color;
            boss.ai = config.ai;
            boss.bodyMaterial = bodyMat;
            boss.velocityY = 0;
            boss.aiState = 'idle';
            boss.aiTimer = 0;
            boss.phase = 1;
            boss.chargeSpeed = 0.25;
            boss.position.set(0, config.size, -35);
            scene.add(boss);
            currentBoss = boss;
            showBossHealthBar(config.name);
        }
        
        function updateBoss() {
            if (!currentBoss) return;
            const boss = currentBoss;
            boss.aiTimer++;
            const healthPercent = boss.health / boss.maxHealth;
            if (healthPercent < 0.33 && boss.phase < 3) { boss.phase = 3; boss.speed *= 1.3; }
            else if (healthPercent < 0.66 && boss.phase < 2) { boss.phase = 2; boss.speed *= 1.15; }
            
            switch (boss.ai) {
                case 'pillarGuardian': updatePillarGuardianAI(boss); break;
                case 'slimeQueen': updateSlimeQueenAI(boss); break;
                case 'teleportingTyrant': updateTeleportingTyrantAI(boss); break;
                case 'balloonKing': updateBalloonKingAI(boss); break;
                case 'tunnelWyrm': updateTunnelWyrmAI(boss); break;
                case 'chaosIncarnate': updateChaosIncarnateAI(boss); break;
                default: updateDefaultBossAI(boss);
            }
            
            boss.velocityY = (boss.velocityY || 0) - 0.015;
            boss.position.y += boss.velocityY;
            if (boss.position.y < boss.size) { boss.position.y = boss.size; boss.velocityY = 0; }
            
            const distToPlayer = boss.position.distanceTo(player.position);
            if (distToPlayer < boss.size * boss.scale.x + 0.5) {
                const now = Date.now();
                if (now - lastDamageTime > DAMAGE_COOLDOWN) { takeDamage(boss.damage); lastDamageTime = now; }
            }
            updateBossHealthBar();
        }
        
        function updateDefaultBossAI(boss) {
            tempVec3.subVectors(player.position, boss.position);
            tempVec3.y = 0;
            tempVec3.normalize();
            boss.position.add(tempVec3.multiplyScalar(boss.speed));
            boss.position.x = Math.max(-42, Math.min(42, boss.position.x));
            boss.position.z = Math.max(-42, Math.min(42, boss.position.z));
        }
        
        function updatePillarGuardianAI(boss) {
            if (boss.aiState === 'idle') {
                updateDefaultBossAI(boss);
                if (boss.aiTimer > 200 && Math.random() < 0.02 * boss.phase) { boss.aiState = 'summon'; boss.aiTimer = 0; }
                if (boss.aiTimer > 150) { boss.aiState = 'wind_up'; boss.aiTimer = 0; boss.bodyMaterial.emissiveIntensity = 1; }
            } else if (boss.aiState === 'wind_up') {
                if (boss.aiTimer > 60) {
                    boss.aiState = 'charging';
                    boss.chargeDirection = tempVec3.subVectors(player.position, boss.position).normalize();
                    boss.chargeDirection.y = 0;
                    boss.aiTimer = 0;
                }
            } else if (boss.aiState === 'charging') {
                boss.position.add(boss.chargeDirection.clone().multiplyScalar(boss.chargeSpeed));
                if (boss.aiTimer > 35 || Math.abs(boss.position.x) > 42 || Math.abs(boss.position.z) > 42) {
                    boss.aiState = 'cooldown';
                    boss.aiTimer = 0;
                    boss.bodyMaterial.emissiveIntensity = 0.5;
                    boss.position.x = Math.max(-42, Math.min(42, boss.position.x));
                    boss.position.z = Math.max(-42, Math.min(42, boss.position.z));
                }
            } else if (boss.aiState === 'summon') {
                if (boss.aiTimer === 30) for (let i = 0; i < boss.phase; i++) spawnSpecificEnemy('fastBouncer', boss.position);
                if (boss.aiTimer > 60) { boss.aiState = 'idle'; boss.aiTimer = 0; }
            } else if (boss.aiState === 'cooldown') {
                if (boss.aiTimer > 80) { boss.aiState = 'idle'; boss.aiTimer = 0; }
            }
        }
        
        function updateSlimeQueenAI(boss) {
            if (boss.aiState === 'idle') {
                updateDefaultBossAI(boss);
                if (boss.aiTimer % 60 === 0) createHazardZone(boss.position.x, boss.position.z, 2 + boss.phase * 0.5, 300);
                if (boss.aiTimer > 180) { boss.aiState = 'jump_prep'; boss.aiTimer = 0; }
            } else if (boss.aiState === 'jump_prep') {
                boss.bodyMaterial.emissiveIntensity = 1;
                if (boss.aiTimer > 40) { boss.aiState = 'jumping'; boss.velocityY = 0.45; boss.jumpTarget = player.position.clone(); boss.aiTimer = 0; }
            } else if (boss.aiState === 'jumping') {
                tempVec3.subVectors(boss.jumpTarget, boss.position); tempVec3.y = 0; tempVec3.normalize();
                boss.position.add(tempVec3.multiplyScalar(0.15));
                if (boss.position.y <= boss.size + 0.1 && boss.velocityY < 0) {
                    boss.aiState = 'landed'; boss.aiTimer = 0; boss.bodyMaterial.emissiveIntensity = 0.5;
                    if (player.position.distanceTo(boss.position) < 6) takeDamage(boss.damage * 0.6);
                    createHazardZone(boss.position.x, boss.position.z, 4, 400);
                    spawnParticle(boss.position, 0x44ff88, 25);
                }
            } else if (boss.aiState === 'landed') {
                if (boss.aiTimer > 60) {
                    if (boss.phase >= 2 && Math.random() < 0.5) for (let i = 0; i < boss.phase; i++) spawnSpecificEnemy('grunt', boss.position);
                    boss.aiState = 'idle'; boss.aiTimer = 0;
                }
            }
        }
        
        function updateTeleportingTyrantAI(boss) {
            if (boss.aiState === 'idle') {
                updateDefaultBossAI(boss);
                if (boss.aiTimer > 120 + Math.random() * 60) { boss.aiState = 'teleport_out'; boss.aiTimer = 0; }
            } else if (boss.aiState === 'teleport_out') {
                boss.scale.setScalar(Math.max(0, 1 - boss.aiTimer / 30));
                if (boss.aiTimer > 30) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 15 + Math.random() * 15;
                    boss.position.x = Math.max(-40, Math.min(40, player.position.x + Math.cos(angle) * dist));
                    boss.position.z = Math.max(-40, Math.min(40, player.position.z + Math.sin(angle) * dist));
                    boss.aiState = 'teleport_in'; boss.aiTimer = 0;
                    spawnParticle(boss.position, 0xaa44ff, 15);
                }
            } else if (boss.aiState === 'teleport_in') {
                boss.scale.setScalar(Math.min(1, boss.aiTimer / 30));
                if (boss.aiTimer > 30) {
                    boss.scale.setScalar(1);
                    if (boss.phase >= 2 && Math.random() < 0.4) spawnSpecificEnemy('teleporter', boss.position);
                    boss.aiState = 'idle'; boss.aiTimer = 0;
                }
            }
        }
        
        function updateBalloonKingAI(boss) {
            updateDefaultBossAI(boss);
            if (boss.scale.x < 1.3) boss.scale.multiplyScalar(1.0005);
            if (boss.aiTimer > 200 && Math.random() < 0.02 * boss.phase) spawnSpecificEnemy('waterBalloon', boss.position);
            if (boss.aiTimer > 150 && boss.aiTimer % 100 === 0) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 8 + Math.random() * 10;
                createHazardZone(boss.position.x + Math.cos(angle)*dist, boss.position.z + Math.sin(angle)*dist, 3 + boss.phase, 300);
            }
            if (boss.phase === 3 && !boss.hasSplit && boss.health < boss.maxHealth * 0.25) {
                boss.hasSplit = true;
                for (let i = 0; i < 3; i++) spawnMiniBoss(boss.position, i);
            }
        }
        
        function updateTunnelWyrmAI(boss) {
            if (boss.aiState === 'idle') {
                updateDefaultBossAI(boss);
                if (boss.aiTimer > 180) { boss.aiState = 'burrowing'; boss.aiTimer = 0; }
            } else if (boss.aiState === 'burrowing') {
                boss.position.y -= 0.1;
                if (boss.position.y < -2) {
                    boss.position.x = player.position.x + (Math.random() - 0.5) * 10;
                    boss.position.z = player.position.z + (Math.random() - 0.5) * 10;
                    boss.aiState = 'emerging'; boss.aiTimer = 0;
                }
            } else if (boss.aiState === 'emerging') {
                boss.position.y += 0.15;
                if (boss.position.y >= boss.size) {
                    boss.position.y = boss.size; boss.aiState = 'idle'; boss.aiTimer = 0;
                    if (player.position.distanceTo(boss.position) < 5) takeDamage(boss.damage * 0.8);
                    spawnParticle(boss.position, 0xff44ff, 20);
                }
            }
        }
        
        function updateChaosIncarnateAI(boss) {
            const pattern = Math.floor(boss.aiTimer / 300) % 5;
            switch (pattern) {
                case 0: updatePillarGuardianAI(boss); break;
                case 1: updateSlimeQueenAI(boss); break;
                case 2: updateTeleportingTyrantAI(boss); break;
                case 3: updateBalloonKingAI(boss); break;
                case 4: updateTunnelWyrmAI(boss); break;
            }
        }
        
        function spawnSpecificEnemy(typeName, nearPosition) {
            const typeData = ENEMY_TYPES[typeName];
            if (!typeData) return;
            const angle = Math.random() * Math.PI * 2;
            const dist = 3 + Math.random() * 5;
            const x = Math.max(-42, Math.min(42, nearPosition.x + Math.cos(angle) * dist));
            const z = Math.max(-42, Math.min(42, nearPosition.z + Math.sin(angle) * dist));
            
            const enemy = new THREE.Mesh(new THREE.SphereGeometry(typeData.size, 10, 10), new THREE.MeshStandardMaterial({ color: typeData.color, emissive: typeData.color, emissiveIntensity: 0.3 }));
            enemy.position.set(x, typeData.size, z);
            enemy.castShadow = true;
            enemy.health = typeData.health; enemy.maxHealth = typeData.health;
            enemy.speed = typeData.speed; enemy.damage = typeData.damage;
            enemy.size = typeData.size; enemy.baseSize = typeData.size;
            enemy.isBoss = false; enemy.isElite = false;
            enemy.xpValue = typeData.xpValue; enemy.baseColor = typeData.color;
            enemy.velocityY = 0; enemy.velocity = new THREE.Vector3();
            enemy.enemyType = typeName; enemy.behavior = typeData.behavior;
            enemy.damageReduction = typeData.damageReduction || 0;
            
            if (typeData.behavior === 'bouncer') enemy.velocity.set((Math.random()-0.5)*enemy.speed*2, 0, (Math.random()-0.5)*enemy.speed*2);
            if (typeData.behavior === 'teleporter') { enemy.teleportCooldown = typeData.teleportCooldown; enemy.teleportRange = typeData.teleportRange; enemy.lastTeleport = Date.now(); }
            if (typeData.behavior === 'waterBalloon') { enemy.growRate = typeData.growRate; enemy.maxSize = typeData.maxSize; enemy.explosionRadius = typeData.explosionRadius; }
            
            scene.add(enemy);
            enemies.push(enemy);
        }
        
        function spawnMiniBoss(position, index) {
            const angle = (index / 3) * Math.PI * 2;
            const miniBoss = new THREE.Mesh(new THREE.SphereGeometry(1.5, 12, 12), new THREE.MeshStandardMaterial({ color: 0x66ffff, emissive: 0x44ffff, emissiveIntensity: 0.4 }));
            miniBoss.position.set(position.x + Math.cos(angle)*5, 1.5, position.z + Math.sin(angle)*5);
            miniBoss.castShadow = true;
            miniBoss.health = 150; miniBoss.maxHealth = 150; miniBoss.speed = 0.04; miniBoss.damage = 15;
            miniBoss.size = 1.5; miniBoss.baseSize = 1.5; miniBoss.isBoss = false; miniBoss.isElite = true;
            miniBoss.xpValue = 20; miniBoss.baseColor = 0x66ffff; miniBoss.velocityY = 0;
            miniBoss.velocity = new THREE.Vector3(); miniBoss.enemyType = 'miniBoss'; miniBoss.behavior = 'chase'; miniBoss.damageReduction = 0.3;
            scene.add(miniBoss);
            enemies.push(miniBoss);
        }
        
        function killBoss() {
            if (!currentBoss) return;
            for (let i = 0; i < 12; i++) {
                const offset = new THREE.Vector3((Math.random()-0.5)*6, 0, (Math.random()-0.5)*6);
                spawnXpGem(currentBoss.position.clone().add(offset), currentBoss.xpValue / 12);
            }
            spawnHeart(currentBoss.position.clone(), HEART_HEAL.boss);
            spawnParticle(currentBoss.position, currentBoss.baseColor, 40);
            currentBoss.traverse(child => { if (child.geometry) child.geometry.dispose(); if (child.material) child.material.dispose(); });
            scene.remove(currentBoss);
            currentBoss = null;
            gameState.bossActive = false;
            hideBossHealthBar();
            gameState.kills++; gameState.score += 750;
            
            // Boss defeated music
            PulseMusic.onBossDefeat();
            
            updateUI();
        }

        // Mechanic Unlocks
        function unlockArenaMechanics(defeatedArena) {
            let unlockMessage = '';
            switch (defeatedArena) {
                case 1: gameState.unlockedMechanics.pillars = true; unlockMessage = 'PILLARS & COVER'; break;
                case 2: gameState.unlockedMechanics.ramps = true; gameState.unlockedEnemyBehaviors.jumping = true; unlockMessage = 'VERTICALITY - Enemies can jump!'; break;
                case 3: gameState.unlockedMechanics.platforms = true; gameState.unlockedEnemyBehaviors.multiLevel = true; unlockMessage = 'MULTI-PLATFORM COMBAT'; break;
                case 4: gameState.unlockedMechanics.tunnels = true; gameState.unlockedEnemyBehaviors.ambush = true; unlockMessage = 'TUNNELS & AMBUSHES'; break;
                case 5: gameState.unlockedMechanics.hybridChaos = true; unlockMessage = 'CHAOS MODE UNLOCKED'; break;
            }
            if (unlockMessage) showUnlockNotification(unlockMessage);
        }

        // UI Functions
        function showWaveAnnouncement() {
            const el = document.getElementById('wave-announcement');
            const arenaConfig = ARENA_CONFIG.arenas[Math.min(gameState.currentArena, 6)];
            el.querySelector('.wave-text').textContent = 'WAVE ' + gameState.currentWave;
            el.querySelector('.arena-text').textContent = 'Arena ' + gameState.currentArena + ' - ' + arenaConfig.name;
            el.classList.add('visible');
        }
        function hideWaveAnnouncement() { document.getElementById('wave-announcement').classList.remove('visible'); }
        function showBossAnnouncement() {
            const el = document.getElementById('wave-announcement');
            el.querySelector('.wave-text').textContent = 'BOSS INCOMING';
            el.querySelector('.arena-text').textContent = BOSS_CONFIG[Math.min(gameState.currentArena, 6)].name;
            el.classList.add('visible');
        }
        function hideBossAnnouncement() { document.getElementById('wave-announcement').classList.remove('visible'); }
        function showBossHealthBar(name) { document.getElementById('boss-name').textContent = name; document.getElementById('boss-health-container').style.display = 'block'; }
        function updateBossHealthBar() { if (currentBoss) document.getElementById('boss-health-bar').style.width = (currentBoss.health / currentBoss.maxHealth * 100) + '%'; }
        function hideBossHealthBar() { document.getElementById('boss-health-container').style.display = 'none'; }
        function showUnlockNotification(text) {
            const el = document.getElementById('unlock-notification');
            document.getElementById('unlock-text').textContent = text;
            el.classList.add('visible');
            setTimeout(() => el.classList.remove('visible'), 3000);
        }
        function updateUI() {
            document.getElementById('health-bar').style.width = Math.min(100, gameState.health / gameState.maxHealth * 100) + '%';
            document.getElementById('xp-bar').style.width = Math.min(100, gameState.xp / gameState.xpToLevel * 100) + '%';
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('kills').textContent = gameState.kills;
            document.getElementById('score').textContent = gameState.score;
            const arenaConfig = ARENA_CONFIG.arenas[Math.min(gameState.currentArena, 6)];
            document.getElementById('arena-num').textContent = gameState.currentArena;
            document.getElementById('arena-name').textContent = arenaConfig.name;
            document.getElementById('wave-num').textContent = gameState.currentWave;
            document.getElementById('waves-total').textContent = WAVES_PER_ARENA;
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            document.getElementById('timer').textContent = Math.floor(elapsed/60) + ':' + (elapsed%60).toString().padStart(2, '0');
        }

        // Pickups
        function spawnHeart(position, healAmount) {
            const heartGroup = new THREE.Group();
            const heartMat = new THREE.MeshBasicMaterial({ color: 0xff4488, transparent: true, opacity: 0.9 });
            const sphereGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const left = new THREE.Mesh(sphereGeo, heartMat); left.position.set(-0.1, 0.1, 0); heartGroup.add(left);
            const right = new THREE.Mesh(sphereGeo, heartMat.clone()); right.position.set(0.1, 0.1, 0); heartGroup.add(right);
            const cone = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.3, 8), heartMat.clone()); cone.position.y = -0.1; cone.rotation.x = Math.PI; heartGroup.add(cone);
            heartGroup.position.copy(position); heartGroup.position.y = 0.5;
            heartGroup.healAmount = healAmount; heartGroup.bobOffset = Math.random() * Math.PI * 2; heartGroup.ttl = HEART_TTL;
            scene.add(heartGroup); hearts.push(heartGroup);
        }
        
        // Vertical Aim Lock-on (Feature 2)
        function getNearestEnemies(count, maxRange) {
            maxRange = maxRange || 35;
            const allTargets = [...enemies];
            if (currentBoss) allTargets.push(currentBoss);
            return allTargets
                .map(e => { const dx = e.position.x - player.position.x, dz = e.position.z - player.position.z; return { enemy: e, dist: Math.sqrt(dx*dx + dz*dz) }; })
                .filter(e => e.dist < maxRange)
                .sort((a, b) => a.dist - b.dist)
                .slice(0, count)
                .map(e => e.enemy);
        }

        function shootProjectile() {
            const now = Date.now();
            const fireRate = 500 / gameState.stats.attackSpeed;
            if (now - lastShot < fireRate) return;
            lastShot = now;
            const projectileCount = Math.floor(gameState.stats.projectileCount);
            const targets = getNearestEnemies(projectileCount);
            if (targets.length === 0) return;
            for (let i = 0; i < projectileCount; i++) {
                const target = targets[i % targets.length];
                const projectile = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshBasicMaterial({ color: 0x44ffff, transparent: true, opacity: 0.9 }));
                projectile.position.copy(player.position); projectile.position.y += 0.5;
                // Vertical aim lock-on: target enemy center
                tempVec3.copy(target.position);
                const direction = tempVec3_2.subVectors(tempVec3, projectile.position).normalize();
                projectile.velocity = direction.clone().multiplyScalar(gameState.stats.projectileSpeed);
                projectile.damage = gameState.stats.damage;
                projectile.life = 120;
                scene.add(projectile); projectiles.push(projectile);
            }
        }
        
        function spawnEnemyProjectile(enemy, targetPos) {
            const projectile = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 6), new THREE.MeshBasicMaterial({ color: 0xff6644, transparent: true, opacity: 0.9 }));
            projectile.position.copy(enemy.position);
            projectile.velocity = tempVec3.subVectors(targetPos, enemy.position).normalize().clone().multiplyScalar(0.3);
            projectile.damage = enemy.damage * 0.5;
            projectile.life = 150;
            scene.add(projectile); enemyProjectiles.push(projectile);
            
            // Enemy attack sound
            PulseMusic.onEnemyAttack(enemy);
        }

        function spawnXpGem(position, value) {
            const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.2, 0), new THREE.MeshBasicMaterial({ color: 0x44ff44, transparent: true, opacity: 0.9 }));
            gem.position.copy(position); gem.position.y = 0.5;
            gem.value = value * gameState.stats.xpMultiplier;
            gem.bobOffset = Math.random() * Math.PI * 2;
            scene.add(gem); xpGems.push(gem);
        }

        function spawnParticle(position, color, count) {
            count = count || 5;
            for (let i = 0; i < count; i++) {
                const particle = new THREE.Mesh(new THREE.SphereGeometry(0.1, 4, 4), new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 }));
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3((Math.random()-0.5)*0.3, Math.random()*0.3, (Math.random()-0.5)*0.3);
                particle.life = 30;
                scene.add(particle); particles.push(particle);
            }
        }

        // Update Functions
        function updatePlayer(delta) {
            const moveDir = new THREE.Vector3();
            const forward = tempVec3.set(0, 0, -1).applyAxisAngle(tempVec3_2.set(0, 1, 0), cameraAngleX);
            const right = tempVec3_3.set(1, 0, 0).applyAxisAngle(tempVec3_2.set(0, 1, 0), cameraAngleX);
            if (keys['KeyW']) moveDir.add(forward.clone());
            if (keys['KeyS']) moveDir.sub(forward.clone());
            if (keys['KeyA']) moveDir.sub(right.clone());
            if (keys['KeyD']) moveDir.add(right.clone());
            moveDir.normalize();
            
            const now = Date.now();
            if ((keys['ShiftLeft'] || keys['ShiftRight']) && now - lastDash > 1000 && moveDir.length() > 0) {
                isDashing = true; lastDash = now; dashDirection.copy(moveDir);
            }
            
            const oldX = player.position.x, oldZ = player.position.z, oldY = player.position.y;
            if (isDashing) { if (now - lastDash < 200) player.position.add(dashDirection.clone().multiplyScalar(0.5)); else isDashing = false; }
            else if (moveDir.length() > 0) player.position.add(moveDir.multiplyScalar(gameState.stats.moveSpeed));
            
            // Platform collision (Feature 1)
            const playerRadius = 0.5;
            for (const obs of obstacles) {
                const c = obs.collisionData;
                if (player.position.y < c.topY + 0.1) {
                    if (player.position.x + playerRadius > c.minX && player.position.x - playerRadius < c.maxX && oldZ + playerRadius > c.minZ && oldZ - playerRadius < c.maxZ && player.position.y < c.topY) {
                        if (oldX <= c.minX) player.position.x = c.minX - playerRadius;
                        else if (oldX >= c.maxX) player.position.x = c.maxX + playerRadius;
                    }
                    if (player.position.x + playerRadius > c.minX && player.position.x - playerRadius < c.maxX && player.position.z + playerRadius > c.minZ && player.position.z - playerRadius < c.maxZ && player.position.y < c.topY) {
                        if (oldZ <= c.minZ) player.position.z = c.minZ - playerRadius;
                        else if (oldZ >= c.maxZ) player.position.z = c.maxZ + playerRadius;
                    }
                }
            }
            
            // Jumping with bounce feedback (Feature 6)
            if (keys['Space'] && player.isGrounded) {
                player.velocity.y = PLAYER_JUMP_VELOCITY;
                player.isGrounded = false;
                player.wasInAir = true;
                player.bounceCount = 0;
                player.squashTime = 8;
            }
            
            player.velocity.y -= PLAYER_GRAVITY;
            player.position.y += player.velocity.y;
            
            // Ground/Platform landing (Feature 1)
            let groundY = 1;
            for (const obs of obstacles) {
                const c = obs.collisionData;
                if (player.position.x + playerRadius > c.minX && player.position.x - playerRadius < c.maxX && player.position.z + playerRadius > c.minZ && player.position.z - playerRadius < c.maxZ) {
                    if (oldY >= c.topY + 0.9 && player.position.y < c.topY + 1.1) groundY = Math.max(groundY, c.topY + 1);
                    else if (player.position.y >= c.topY + 0.8 && player.position.y < c.topY + 1.3 && player.velocity.y <= 0) groundY = Math.max(groundY, c.topY + 1);
                }
            }
            
            if (player.position.y < groundY) {
                player.position.y = groundY;
                if (player.wasInAir) {
                    if (player.bounceCount < BOUNCE_FACTORS.length) {
                        player.velocity.y = PLAYER_JUMP_VELOCITY * BOUNCE_FACTORS[player.bounceCount];
                        player.bounceCount++;
                        player.squashTime = 6 - player.bounceCount * 2;
                        if (player.bounceCount === 1) spawnParticle(player.position, 0x44aaff, 5);
                    } else { player.velocity.y = 0; player.isGrounded = true; player.wasInAir = false; player.bounceCount = 0; }
                } else { player.velocity.y = 0; player.isGrounded = true; }
            } else player.isGrounded = false;
            
            // Squash/stretch animation (Feature 6)
            if (player.squashTime > 0) {
                player.squashTime--;
                player.scale.set(1 + player.squashTime * 0.02, 1 - player.squashTime * 0.03, 1 + player.squashTime * 0.02);
            } else player.scale.set(1, 1, 1);
            
            player.position.x = Math.max(-45, Math.min(45, player.position.x));
            player.position.z = Math.max(-45, Math.min(45, player.position.z));
            
            // Enhanced trail (Feature 5)
            const isMoving = moveDir.length() > 0 || isDashing;
            if (isMoving && player.isGrounded && (!lastTrailPos || player.position.distanceTo(lastTrailPos) > TRAIL_SPAWN_DISTANCE)) {
                spawnTrail(player.position.clone());
                lastTrailPos = player.position.clone();
            }
            
            // Hazard damage
            for (const hz of hazardZones) {
                const dx = player.position.x - hz.position.x, dz = player.position.z - hz.position.z;
                if (Math.sqrt(dx*dx + dz*dz) < hz.radius && player.position.y < 1.5) {
                    gameState.health -= hz.damagePerFrame;
                    if (gameState.health <= 0) { gameState.health = 0; gameOver(); }
                }
            }
            
            // Camera
            camera.position.x = player.position.x + Math.sin(cameraAngleX) * 8;
            camera.position.z = player.position.z + Math.cos(cameraAngleX) * 8;
            camera.position.y = player.position.y + 4 + Math.sin(cameraAngleY) * 3;
            camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
        }

        function updateEnemies(delta) {
            const now = Date.now();
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (!enemy.velocityY) enemy.velocityY = 0;
                
                switch (enemy.behavior) {
                    case 'chase': updateChaseEnemy(enemy); break;
                    case 'shooter': updateShooterEnemy(enemy, now); break;
                    case 'bouncer': updateBouncerEnemy(enemy); break;
                    case 'shieldBreaker': updateShieldBreakerEnemy(enemy); break;
                    case 'waterBalloon': updateWaterBalloonEnemy(enemy); break;
                    case 'teleporter': updateTeleporterEnemy(enemy, now); break;
                    default: updateChaseEnemy(enemy);
                }
                
                enemy.velocityY -= 0.012;
                enemy.position.y += enemy.velocityY;
                
                let groundY = enemy.baseSize * enemy.scale.x;
                if (gameState.unlockedEnemyBehaviors.jumping) {
                    for (const obs of obstacles) {
                        const c = obs.collisionData;
                        const s = enemy.baseSize * enemy.scale.x;
                        if (enemy.position.x + s > c.minX && enemy.position.x - s < c.maxX && enemy.position.z + s > c.minZ && enemy.position.z - s < c.maxZ && enemy.position.y >= c.topY)
                            groundY = Math.max(groundY, c.topY + s);
                    }
                }
                if (enemy.position.y < groundY) { enemy.position.y = groundY; enemy.velocityY = 0; }
                
                enemy.rotation.y += 0.04;
                
                const scaledSize = enemy.baseSize * enemy.scale.x;
                if (enemy.position.distanceTo(player.position) < scaledSize + 0.5) {
                    if (now - lastDamageTime > DAMAGE_COOLDOWN) { takeDamage(enemy.damage); lastDamageTime = now; }
                    tempVec3.subVectors(enemy.position, player.position).normalize();
                    enemy.position.add(tempVec3.multiplyScalar(0.5));
                }
            }
        }
        
        function updateChaseEnemy(enemy) {
            tempVec3.subVectors(player.position, enemy.position); tempVec3.y = 0; tempVec3.normalize();
            enemy.position.x += tempVec3.x * enemy.speed;
            enemy.position.z += tempVec3.z * enemy.speed;
            if (gameState.unlockedEnemyBehaviors.jumping) {
                for (const obs of obstacles) {
                    const c = obs.collisionData;
                    const s = enemy.baseSize * enemy.scale.x;
                    if (enemy.position.x + s > c.minX && enemy.position.x - s < c.maxX && enemy.position.z + s > c.minZ && enemy.position.z - s < c.maxZ)
                        if (enemy.velocityY <= 0 && enemy.position.y < c.topY + s + 0.5) enemy.velocityY = 0.1;
                }
            }
        }
        
        function updateShooterEnemy(enemy, now) {
            const dist = enemy.position.distanceTo(player.position);
            if (dist > enemy.shootRange) {
                tempVec3.subVectors(player.position, enemy.position); tempVec3.y = 0; tempVec3.normalize();
                enemy.position.x += tempVec3.x * enemy.speed;
                enemy.position.z += tempVec3.z * enemy.speed;
            } else if (dist < enemy.shootRange * 0.5) {
                tempVec3.subVectors(enemy.position, player.position); tempVec3.y = 0; tempVec3.normalize();
                enemy.position.x += tempVec3.x * enemy.speed * 0.5;
                enemy.position.z += tempVec3.z * enemy.speed * 0.5;
            }
            if (dist < enemy.shootRange && now - (enemy.lastShot || 0) > enemy.shootCooldown) {
                spawnEnemyProjectile(enemy, player.position.clone());
                enemy.lastShot = now;
            }
        }
        
        function updateBouncerEnemy(enemy) {
            enemy.position.x += enemy.velocity.x;
            enemy.position.z += enemy.velocity.z;
            if (enemy.position.x < -42 || enemy.position.x > 42) { enemy.velocity.x *= -1; enemy.position.x = Math.max(-42, Math.min(42, enemy.position.x)); }
            if (enemy.position.z < -42 || enemy.position.z > 42) { enemy.velocity.z *= -1; enemy.position.z = Math.max(-42, Math.min(42, enemy.position.z)); }
            for (const obs of obstacles) {
                const c = obs.collisionData;
                if (enemy.position.x + enemy.size > c.minX && enemy.position.x - enemy.size < c.maxX && enemy.position.z + enemy.size > c.minZ && enemy.position.z - enemy.size < c.maxZ) {
                    enemy.velocity.x *= -1; enemy.velocity.z *= -1;
                    enemy.position.x += enemy.velocity.x * 2; enemy.position.z += enemy.velocity.z * 2;
                }
            }
            tempVec3.subVectors(player.position, enemy.position).normalize();
            enemy.velocity.x += tempVec3.x * 0.001;
            enemy.velocity.z += tempVec3.z * 0.001;
            const speed = Math.sqrt(enemy.velocity.x*enemy.velocity.x + enemy.velocity.z*enemy.velocity.z);
            if (speed > enemy.speed) { enemy.velocity.x = enemy.velocity.x/speed*enemy.speed; enemy.velocity.z = enemy.velocity.z/speed*enemy.speed; }
        }
        
        function updateShieldBreakerEnemy(enemy) {
            const dist = enemy.position.distanceTo(player.position);
            if (dist < enemy.rushRange && !enemy.isRushing) {
                enemy.isRushing = true;
                enemy.rushDirection = tempVec3.subVectors(player.position, enemy.position).normalize().clone();
                enemy.rushDirection.y = 0;
            }
            if (enemy.isRushing) {
                enemy.position.add(enemy.rushDirection.clone().multiplyScalar(enemy.rushSpeed));
                if (Math.abs(enemy.position.x) > 42 || Math.abs(enemy.position.z) > 42) {
                    enemy.isRushing = false;
                    enemy.position.x = Math.max(-42, Math.min(42, enemy.position.x));
                    enemy.position.z = Math.max(-42, Math.min(42, enemy.position.z));
                }
            } else updateChaseEnemy(enemy);
        }
        
        function updateWaterBalloonEnemy(enemy) {
            tempVec3.subVectors(player.position, enemy.position); tempVec3.y = 0; tempVec3.normalize();
            enemy.position.x += tempVec3.x * enemy.speed;
            enemy.position.z += tempVec3.z * enemy.speed;
            if (enemy.size < enemy.maxSize) { enemy.size += enemy.growRate; enemy.scale.setScalar(enemy.size / enemy.baseSize); }
            else explodeWaterBalloon(enemy);
        }
        
        function explodeWaterBalloon(enemy) {
            createHazardZone(enemy.position.x, enemy.position.z, enemy.explosionRadius, 400);
            if (player.position.distanceTo(enemy.position) < enemy.explosionRadius) takeDamage(enemy.damage * 2);
            spawnParticle(enemy.position, 0x44ffff, 20);
            enemy.health = 0;
        }
        
        function updateTeleporterEnemy(enemy, now) {
            const dist = enemy.position.distanceTo(player.position);
            if (now - (enemy.lastTeleport || 0) > enemy.teleportCooldown && dist < 20) {
                const angle = Math.random() * Math.PI * 2;
                const d = 3 + Math.random() * 3;
                spawnParticle(enemy.position, 0xaa44ff, 8);
                enemy.position.x = Math.max(-42, Math.min(42, player.position.x + Math.cos(angle) * d));
                enemy.position.z = Math.max(-42, Math.min(42, player.position.z + Math.sin(angle) * d));
                spawnParticle(enemy.position, 0xaa44ff, 8);
                enemy.lastTeleport = now;
            } else {
                tempVec3.subVectors(player.position, enemy.position); tempVec3.y = 0; tempVec3.normalize();
                enemy.position.x += tempVec3.x * enemy.speed * 0.5;
                enemy.position.z += tempVec3.z * enemy.speed * 0.5;
            }
        }

        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.position.add(proj.velocity);
                proj.life--;
                let hit = false;
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const hitboxSize = enemy.baseSize * enemy.scale.x * 0.85;
                    if (proj.position.distanceTo(enemy.position) < hitboxSize + 0.2) {
                        enemy.health -= proj.damage * (1 - (enemy.damageReduction || 0));
                        spawnParticle(proj.position, 0xff4444, 3);
                        const healthPercent = Math.max(0, enemy.health / enemy.maxHealth);
                        enemy.scale.setScalar(0.65 + 0.35 * healthPercent);
                        enemy.material.emissive.setHex(0xffffff);
                        enemy.material.emissiveIntensity = 1;
                        setTimeout(() => { if (enemy.material) { enemy.material.emissive.setHex(enemy.baseColor); enemy.material.emissiveIntensity = 0.3; } }, 50);
                        if (enemy.health <= 0) {
                            if (enemy.onDeath === 'split') for (let s = 0; s < enemy.splitCount; s++) spawnSplitEnemy(enemy.position, enemy.baseSize);
                            if (enemy.behavior === 'waterBalloon') explodeWaterBalloon(enemy);
                            spawnXpGem(enemy.position, enemy.xpValue);
                            spawnParticle(enemy.position, enemy.baseColor, 10);
                            if (Math.random() < (enemy.isElite ? HEART_DROP_CHANCE.elite : HEART_DROP_CHANCE.normal))
                                spawnHeart(enemy.position.clone(), enemy.isElite ? HEART_HEAL.elite : HEART_HEAL.normal);
                            
                            // Enemy death sound
                            PulseMusic.onEnemyDeath(enemy);
                            
                            enemy.geometry.dispose(); enemy.material.dispose(); scene.remove(enemy);
                            enemies.splice(j, 1);
                            gameState.kills++; gameState.score += enemy.isElite ? 30 : 10;
                        }
                        hit = true; break;
                    }
                }
                
                if (!hit && currentBoss && proj.position.distanceTo(currentBoss.position) < currentBoss.size * currentBoss.scale.x + 0.2) {
                    currentBoss.health -= proj.damage;
                    spawnParticle(proj.position, 0xff4444, 3);
                    currentBoss.scale.setScalar(0.75 + 0.25 * Math.max(0, currentBoss.health / currentBoss.maxHealth));
                    if (currentBoss.bodyMaterial) {
                        currentBoss.bodyMaterial.emissive.setHex(0xffffff);
                        setTimeout(() => { if (currentBoss && currentBoss.bodyMaterial) currentBoss.bodyMaterial.emissive.setHex(currentBoss.baseColor); }, 50);
                    }
                    if (currentBoss.health <= 0) killBoss();
                    hit = true;
                }
                
                if (hit || proj.life <= 0) { proj.geometry.dispose(); proj.material.dispose(); scene.remove(proj); projectiles.splice(i, 1); }
            }
            
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const proj = enemyProjectiles[i];
                proj.position.add(proj.velocity);
                proj.life--;
                if (proj.position.distanceTo(player.position) < 1) {
                    const now = Date.now();
                    if (now - lastDamageTime > DAMAGE_COOLDOWN * 0.5) { takeDamage(proj.damage); lastDamageTime = now; }
                    proj.geometry.dispose(); proj.material.dispose(); scene.remove(proj); enemyProjectiles.splice(i, 1); continue;
                }
                if (proj.life <= 0) { proj.geometry.dispose(); proj.material.dispose(); scene.remove(proj); enemyProjectiles.splice(i, 1); }
            }
        }
        
        function updateHazardZones() {
            for (let i = hazardZones.length - 1; i >= 0; i--) {
                const hz = hazardZones[i];
                if (hz.duration > 0) {
                    hz.duration--;
                    if (hz.duration < 60) hz.material.opacity = (hz.duration / 60) * 0.4;
                    if (hz.duration <= 0) { hz.geometry.dispose(); hz.material.dispose(); scene.remove(hz); hazardZones.splice(i, 1); }
                }
            }
        }
        
        function updateHearts(delta) {
            const time = Date.now() * 0.004;
            for (let i = hearts.length - 1; i >= 0; i--) {
                const heart = hearts[i];
                heart.position.y = 0.5 + Math.sin(time + heart.bobOffset) * 0.2;
                heart.rotation.y += 0.03;
                heart.ttl--;
                if (heart.ttl < 60) heart.children.forEach(c => { if (c.material) c.material.opacity = (heart.ttl / 60) * 0.9; });
                if (heart.ttl <= 0) { heart.children.forEach(c => { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); }); scene.remove(heart); hearts.splice(i, 1); continue; }
                const dist = heart.position.distanceTo(player.position);
                if (dist < gameState.stats.pickupRange) { tempVec3.subVectors(player.position, heart.position).normalize(); heart.position.add(tempVec3.multiplyScalar(0.25)); }
                if (dist < 1) {
                    gameState.health = Math.min(gameState.health + heart.healAmount, gameState.maxHealth);
                    spawnParticle(heart.position, 0xff4488, 8);
                    heart.children.forEach(c => { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); });
                    scene.remove(heart); hearts.splice(i, 1);
                }
            }
        }

        function updateXpGems(delta) {
            const time = Date.now() * 0.003;
            for (let i = xpGems.length - 1; i >= 0; i--) {
                const gem = xpGems[i];
                gem.position.y = 0.5 + Math.sin(time + gem.bobOffset) * 0.2;
                gem.rotation.y += 0.05;
                const dist = gem.position.distanceTo(player.position);
                if (dist < gameState.stats.pickupRange) { tempVec3.subVectors(player.position, gem.position).normalize(); gem.position.add(tempVec3.multiplyScalar(0.3)); }
                if (dist < 1) {
                    gameState.xp += gem.value;
                    spawnParticle(gem.position, 0x44ff44, 5);
                    gem.geometry.dispose(); gem.material.dispose(); scene.remove(gem); xpGems.splice(i, 1);
                    while (gameState.xp >= gameState.xpToLevel) { gameState.xp -= gameState.xpToLevel; gameState.pendingLevelUps++; gameState.xpToLevel = Math.floor(gameState.xpToLevel * 1.5); }
                    if (gameState.pendingLevelUps > 0 && !gameState.paused) levelUp();
                }
            }
        }

        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.velocity);
                p.velocity.y -= 0.01;
                p.life--;
                p.material.opacity = p.life / 30;
                if (p.life <= 0) { p.geometry.dispose(); p.material.dispose(); scene.remove(p); particles.splice(i, 1); }
            }
        }

        // Game Flow
        function takeDamage(amount) {
            gameState.health -= amount;
            const flash = document.getElementById('damage-flash');
            flash.style.opacity = '1';
            setTimeout(() => flash.style.opacity = '0', 100);
            if (player && player.bodyMaterial) {
                player.bodyMaterial.emissive.setHex(0xff0000);
                player.bodyMaterial.emissiveIntensity = 1;
                setTimeout(() => { if (player && player.bodyMaterial) { player.bodyMaterial.emissive.setHex(0x224488); player.bodyMaterial.emissiveIntensity = 0.3; } }, DAMAGE_COOLDOWN);
            }
            
            // Player damage sound
            PulseMusic.onPlayerDamage(gameState.health / gameState.maxHealth);
            
            if (gameState.health <= 0) { gameState.health = 0; gameOver(); }
        }

        function levelUp() {
            gameState.level++; gameState.score += 50;
            gameState.pendingLevelUps = Math.max(0, gameState.pendingLevelUps - 1);
            gameState.health = Math.min(gameState.health + 10, gameState.maxHealth);
            
            // Level up sound
            PulseMusic.onLevelUp();
            
            showUpgradeMenu();
        }

        function showUpgradeMenu() {
            gameState.paused = true;
            document.exitPointerLock();
            const options = document.getElementById('upgrade-options');
            options.innerHTML = '';
            const shuffled = [...upgrades].sort(() => Math.random() - 0.5).slice(0, 3);
            shuffled.forEach(upgrade => {
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = '<div class="upgrade-icon">' + upgrade.icon + '</div><div class="upgrade-name">' + upgrade.name + '</div><div class="upgrade-desc">' + upgrade.desc + '</div>';
                card.addEventListener('click', () => selectUpgrade(upgrade));
                options.appendChild(card);
            });
            document.getElementById('upgrade-menu').style.display = 'block';
        }

        function selectUpgrade(upgrade) {
            if (upgrade.mult) gameState.stats[upgrade.stat] *= upgrade.mult;
            else if (upgrade.add) gameState.stats[upgrade.stat] += upgrade.add;
            if (upgrade.stat === 'maxHealth') { gameState.maxHealth = gameState.stats.maxHealth; gameState.health = Math.min(gameState.health + upgrade.add, gameState.maxHealth); }
            document.getElementById('upgrade-menu').style.display = 'none';
            if (gameState.pendingLevelUps > 0) levelUp();
            else gameState.paused = false;
        }

        function gameOver() {
            gameState.running = false;
            document.exitPointerLock();
            
            // Game over music
            PulseMusic.onGameOver();
            
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            document.getElementById('final-time').textContent = Math.floor(elapsed/60) + ':' + (elapsed%60).toString().padStart(2, '0');
            document.getElementById('final-arena').textContent = gameState.currentArena;
            document.getElementById('final-level').textContent = gameState.level;
            document.getElementById('final-kills').textContent = gameState.kills;
            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('game-over').style.display = 'block';
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            generateArena(1);
            gameState.running = true;
            gameState.waveState = WAVE_STATE.WAVE_INTRO;
            gameState.waveTimer = 0;
            gameStartTime = Date.now();
            
            // Start PULSE Music
            PulseMusic.resume();
            PulseMusic.loadArena(1);
            PulseMusic.start();
            
            animate();
        }

        function restartGame() {
            Object.assign(gameState, { health: 100, maxHealth: 100, xp: 0, xpToLevel: 10, level: 1, kills: 0, score: 0, paused: false, currentArena: 1, currentWave: 1, waveState: WAVE_STATE.WAVE_INTRO, waveTimer: 0, bossActive: false, pendingLevelUps: 0 });
            gameState.unlockedMechanics = { pillars: false, ramps: false, platforms: false, tunnels: false, hybridChaos: false };
            gameState.unlockedEnemyBehaviors = { jumping: false, ambush: false, multiLevel: false };
            gameState.stats = { damage: 10, attackSpeed: 1, projectileCount: 1, projectileSpeed: 0.8, moveSpeed: 0.15, maxHealth: 100, pickupRange: 3, xpMultiplier: 1 };
            
            enemies.forEach(e => { if (e.geometry) e.geometry.dispose(); if (e.material) e.material.dispose(); scene.remove(e); });
            projectiles.forEach(p => { p.geometry.dispose(); p.material.dispose(); scene.remove(p); });
            enemyProjectiles.forEach(p => { p.geometry.dispose(); p.material.dispose(); scene.remove(p); });
            xpGems.forEach(g => { g.geometry.dispose(); g.material.dispose(); scene.remove(g); });
            particles.forEach(p => { p.geometry.dispose(); p.material.dispose(); scene.remove(p); });
            hearts.forEach(h => { h.children.forEach(c => { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); }); scene.remove(h); });
            if (currentBoss) { currentBoss.traverse(c => { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); }); scene.remove(currentBoss); currentBoss = null; }
            
            enemies = []; projectiles = []; enemyProjectiles = []; xpGems = []; particles = []; hearts = [];
            trailPool.forEach(t => { t.visible = false; t.life = 0; });
            trailIndex = 0; lastTrailPos = null;
            player.position.set(0, 1, 0); player.velocity.set(0, 0, 0); player.isGrounded = true; player.bounceCount = 0; player.wasInAir = false; player.scale.set(1, 1, 1); player.squashTime = 0;
            generateArena(1);
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('pause-indicator').style.display = 'none';
            document.getElementById('boss-health-container').style.display = 'none';
            lastDamageTime = 0; lastShot = 0; lastDash = 0; isDashing = false; cameraAngleX = 0; cameraAngleY = 0.3;
            
            // Restart PULSE Music
            PulseMusic.stop();
            PulseMusic.loadArena(1);
            PulseMusic.start();
            
            gameState.running = true; gameStartTime = Date.now(); updateUI(); animate();
        }

        function onMouseMove(event) {
            if (!isPointerLocked) return;
            cameraAngleX -= event.movementX * 0.002;
            cameraAngleY = Math.max(-0.5, Math.min(1, cameraAngleY + event.movementY * 0.002));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            if (!gameState.running) return;
            requestAnimationFrame(animate);
            if (!gameState.paused) {
                updatePlayer(1);
                updateEnemies(1);
                updateBoss();
                updateProjectiles(1);
                updateXpGems(1);
                updateHearts(1);
                updateParticles(1);
                updateTrail();
                updateHazardZones();
                updateWaveSystem();
                shootProjectile();
                
                // Update PULSE Music System
                PulseMusic.update(gameState, enemies, currentBoss);
                
                const now = Date.now();
                if (now - lastUIUpdate > UI_UPDATE_INTERVAL) { updateUI(); lastUIUpdate = now; }
            }
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
