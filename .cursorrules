# MantaSphere Development Rules

This document provides guidance for AI agents and developers working on the MantaSphere codebase.

## AI Agent Persona Entry Point

- `AGENTS.md` is the entry point for persona-based behavior.
- If the correct persona is unclear, **start with Director (Orchestrator)** and triage from there.

## Game Identity

MantaSphere is an **arcade-style score runner** built on these pillars:

1. **Progressive Complexity** - Arenas teach mechanics incrementally
2. **Boss Puzzles** - Bosses test learned skills, not just HP pools
3. **Fast Loops** - Short early arenas, quick restarts
4. **Visual Progression** - Badges show investment and mastery
5. **Local Competition** - Leaderboards drive replayability

## Project Overview

Built with:
- **Three.js r134** (loaded via CDN, NOT npm)
- **Vanilla JavaScript** with ES Modules
- **esbuild bundling** - bundles to `dist/bundle.js` for fast dev/prod builds

## Clarifying Questions Protocol

To avoid wrong implementations and wasted work, use **risk-based clarifying questions** when a request has ambiguity, branching choices, unclear success criteria, or high blast-radius.

### When to ask questions (how many)

| Situation | Ask |
|----------|-----|
| Fully specified, low-risk, no meaningful implementation choices | 0 questions (proceed) |
| Simple / low ambiguity (small change, single obvious location) | 1‚Äì2 questions |
| Moderate ambiguity (multiple valid implementations, tradeoffs, unclear constraints) | 2‚Äì3 questions |
| Complex / confusing / high-risk (cross-system, unclear goals, wide scope, unclear repro/acceptance) | 4‚Äì10 questions |

### Question quality rules

- Ask only questions whose answers can **change the plan or code**.
- Prefer **fewer, higher-leverage** questions over many small ones.
- Keep questions **short and concrete**; offer **options** (a/b/c) when helpful.
- If information is missing but a reasonable default exists, propose it explicitly and ask for confirmation.
- Bundle clarifying questions into **one message** (don‚Äôt drip-feed).

### Examples (quick rubric)

- **‚ÄúFix this one error in `js/systems/waveSystem.js`‚Äù + exact stack trace provided**: 0‚Äì2 questions (only if multiple plausible fixes).
- **‚ÄúAdd a new enemy‚Äù without desired role/spawn arena/behavior**: 2‚Äì3 questions.
- **‚ÄúRebalance Arena 3 difficulty‚Äù without target difficulty, metrics, or pain point**: 4‚Äì10 questions.

## Critical Rules

### 1. Three.js Usage

**DO NOT** install Three.js via npm. It's loaded via CDN:
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
```

**THREE is a global variable** - modules access it without importing.

**Use r134-compatible APIs only:**
- NO `CapsuleGeometry` (use cylinder + spheres)
- NO modern Three.js features not in r134

### 2. Module Architecture

All game code uses ES Modules. Import pattern:
```javascript
import { CONSTANT } from '../config/constants.js';
import { gameState } from '../core/gameState.js';
import { scene } from '../core/scene.js';
```

**Avoid circular dependencies:**
- Use getter functions for cross-module state
- Entity modules should not import each other's update functions

### 3. State Management

**Central state:** `js/core/gameState.js`
**Entity arrays:** `js/core/entities.js`
**Boss getter:** `getCurrentBoss()` from entities.js

### 4. Design Philosophy

#### Arena Design
Each arena should:
- Introduce ONE new mechanic
- Build on previous arena skills
- Have a boss that tests that mechanic

**Tiered Wave Counts:**
| Arena | Waves | Purpose |
|-------|-------|---------|
| 1 | 3 | Quick intro |
| 2 | 5 | Learn cover |
| 3 | 6 | Learn verticality |
| 4+ | 8-10 | Full challenge |

#### Boss Design
Bosses are **puzzle tests**, not bullet sponges:
- Phase 1: Core mechanic test
- Phase 2: Add arena twist
- Phase 3: Pressure test

Each boss failure should teach something.

#### Badge Design
- **Stat badges** - Earned during run, show build focus
- **Arena badges** - Persistent, show mastery
- Badges should be aspirational but achievable

### 5. Adding New Features

#### New Enemy Type
1. Add to `js/config/enemies.js`
2. Add behavior in `js/entities/enemies.js`
3. Set `minArena` to gate appearance
4. **Include roster display fields:** `tagline`, `description`, `behaviorText`

#### New Boss
1. Add to `js/config/bosses.js`
2. Add AI in `js/entities/boss.js`
3. Add arena badge in `js/config/badges.js`
4. **Include roster display fields:** `tagline`, `description`, `behaviorText`

#### Character Roster Maintenance
The roster screen (`js/ui/rosterUI.js`) dynamically reads from enemy and boss configs.

**When adding/modifying enemies or bosses, always include these display fields:**
```javascript
tagline: 'Short catchy phrase',           // Shows under name
description: 'Lore-friendly explanation', // Main description text
behaviorText: 'What it does in gameplay'  // Green behavior hint
```

**The roster auto-updates when:**
- New enemy/boss configs are added (appears as "???" until encountered)
- Display field text is changed
- Stats/colors are modified

**No separate roster file to maintain** - single source of truth in configs.

#### New Arena
1. Add to `js/config/arenas.js` with:
   - `waves` count
   - `features` array
   - `teaches` description
   - `bossLesson` description
2. Add geometry in `js/arena/generator.js`

#### New Badge
1. Add to `js/config/badges.js`
2. For stat badges: set `stat` and `threshold`
3. For arena badges: set `arena` and `persistent: true`

#### New Upgrade
1. Add to `js/config/upgrades.js`
2. Ensure stat exists in `gameState.stats`
3. Consider adding a badge for high values

### 6. Code Style

**Naming:**
- Functions: `camelCase`
- Constants: `UPPER_SNAKE_CASE`
- Config objects: `UPPER_SNAKE_CASE`

**Performance:**
- Reuse `THREE.Vector3` instances (use tempVec3 from entities.js)
- Use `.length = 0` to clear arrays
- Pool frequently created objects (projectiles, particles, enemies)
- Cache geometries by size - don't create new geometry per spawn
- Share materials when color/properties match
- Use delta time for all movement (never assume fixed framerate)

### 7. Common Patterns

**Spawn Pattern:**
```javascript
export function spawnThing(position) {
    const thing = new THREE.Mesh(geometry, material);
    thing.position.copy(position);
    scene.add(thing);
    thingsArray.push(thing);
    return thing;
}
```

**Boss AI Pattern:**
```javascript
function updateBossAI(boss) {
    if (boss.aiState === 'idle') {
        // Default behavior
        if (condition) {
            boss.aiState = 'attacking';
            boss.aiTimer = 0;
        }
    } else if (boss.aiState === 'attacking') {
        // Attack behavior
        if (boss.aiTimer > duration) {
            boss.aiState = 'idle';
        }
    }
}
```

### 8. Testing Changes

**Local server required:**
```bash
python -m http.server 8000
```

**Test checklist:**
- [ ] Game starts without errors
- [ ] Player can move and shoot
- [ ] Enemies spawn with correct behavior
- [ ] Bosses appear after final wave
- [ ] Level up menu works
- [ ] Pause/resume works
- [ ] Game over triggers correctly
- [ ] Leaderboard saves/loads
- [ ] Badges display correctly
- [ ] Arena transitions work

### 9. File Reference

| File | Purpose |
|------|---------|
| `js/main.js` | Entry point, game loop |
| `js/config/arenas.js` | Arena definitions with lore |
| `js/config/badges.js` | Badge definitions |
| `js/config/bosses.js` | Boss configurations |
| `js/config/enemies.js` | Enemy types |
| `js/core/gameState.js` | Central state |
| `js/systems/badges.js` | Badge tracking |
| `js/systems/leaderboard.js` | Score persistence |
| `js/systems/playtestFeedback.js` | In-game feedback form |
| `js/systems/pulseMusic.js` | Adaptive music system |
| `js/systems/waveSystem.js` | Wave/arena progression |
| `js/ui/hud.js` | HUD updates |
| `js/ui/leaderboardUI.js` | Leaderboard display |
| `js/ui/rosterUI.js` | Character roster (reads from enemy/boss configs) |
| `scripts/feedback-sync.js` | GitHub Action: sync feedback to issues |
| `.github/workflows/feedback-sync.yml` | Daily feedback sync workflow |

### 10. Documentation

| Doc | Purpose |
|-----|---------|
| `docs/PLAYER.md` | Player system - movement, combat, stats, controls |
| `docs/BOSS.md` | Boss system reference - all bosses, abilities, phases |
| `docs/ENEMIES.md` | Enemy roster - all enemy types, behaviors, spawn mechanics |
| `docs/ARENA.md` | Arena progression - wave system, geometry, unlocks |
| `docs/PULSE_MUSIC_SYSTEM.md` | Adaptive music system design |
| `docs/PLAYTEST_FORM_GUIDE.md` | Playtest feedback system setup |
| `AGENTS.md` | Designer personas for feature design |
| `CONTRIBUTING.md` | Contribution guidelines and workflow |

#### Design Prompt Workflow

When working on **feature design** (not just bug fixes), follow this workflow:

1. **Start as Game Director** - Triage the request and decide how to handle it
2. **Route to specialist** (or handle directly if it's high-level/cross-system)
3. **Read current state** from the corresponding documentation
4. **Apply persona principles** to your design decisions

| Request Type | Persona | First Action |
|--------------|---------|--------------|
| **Any design question** | Game Director (first) | Triage and route |
| High-level / cross-system | Game Director | Answer directly |
| Boss fights / abilities | Boss Designer | Read `docs/BOSS.md` |
| Enemy types / waves | Enemy Designer | Read `docs/ENEMIES.md` |
| Arena layout / geometry | Arena Designer | Read `docs/ARENA.md` |
| Music / SFX / audio | Audio Designer | Read `docs/PULSE_MUSIC_SYSTEM.md` |
| Playtest feedback | Playtest Feedback Evaluator | Review feedback + docs |
| Code review / pre-commit | Code Review Auditor | Review code changes |
| Backlog / issues | Technical PM | Check GitHub Issues |

**Example:** When asked to design a new boss:
1. Read `AGENTS.md` -> **Game Director** section (triage first)
2. Director routes to Boss Designer with context and constraints
3. Read `docs/BOSS.md` for current boss implementations
4. Adopt Boss Designer persona (fair, readable, memorable design principles)
5. Apply the design framework to the new boss

**Example:** When asked "Should we add a new game mode?":
1. Read `AGENTS.md` -> **Game Director** section
2. Handle directly as Director (this is high-level / pillar question)
3. Evaluate against game pillars, recommend implement/defer/reject
4. If approved, route implementation details to appropriate specialists

#### Documentation Maintenance Policy

**Before making ANY code changes:**

1. **Review relevant documentation** for the feature you're modifying
   - Working on player? Read `docs/PLAYER.md`
   - Working on bosses? Read `docs/BOSS.md`
   - Working on enemies? Read `docs/ENEMIES.md`
   - Working on arenas? Read `docs/ARENA.md`
   - Working on music? Read `docs/PULSE_MUSIC_SYSTEM.md`

2. **Keep documentation in sync with code**
   - When adding/modifying features, update the corresponding docs
   - When changing behavior, update the behavior descriptions
   - When adjusting stats, update the stat tables

**Before committing changes:**

1. **Search for `TODO`, `FIXME`, `STUB`, empty function bodies** - Ask user to implement before committing
2. **Review docs for accuracy** - Check if your changes require doc updates
3. **Update affected documentation files** in the same commit as code changes

**Documentation-to-Code Mapping:**

| Code Files | Documentation |
|------------|---------------|
| `js/entities/player.js`, `js/systems/damage.js`, `js/systems/projectiles.js`, `js/config/upgrades.js` | `docs/PLAYER.md` |
| `js/config/bosses.js`, `js/entities/boss.js` | `docs/BOSS.md` |
| `js/config/enemies.js`, `js/entities/enemies.js` | `docs/ENEMIES.md` |
| `js/config/arenas.js`, `js/arena/generator.js`, `js/systems/waveSystem.js` | `docs/ARENA.md` |
| `js/systems/pulseMusic.js` | `docs/PULSE_MUSIC_SYSTEM.md` |

**Examples:**

- Adding a new player stat? Update `docs/PLAYER.md` stats table and upgrade that affects it
- Changing movement speed or dash mechanics? Update `docs/PLAYER.md` movement system section
- Adding a new boss ability? Update `docs/BOSS.md` with the ability description, cooldown, and which bosses use it
- Changing enemy spawn weights? Update `docs/ENEMIES.md` spawn weight tables
- Adjusting wave counts? Update `docs/ARENA.md` arena roster table
- Adding new sound events? Update `docs/PULSE_MUSIC_SYSTEM.md` integration points

**Rationale:** Documentation drift causes confusion and wasted time. By enforcing reviews before changes and updates before commits, we keep docs trustworthy and useful.

### 11. Balance Guidelines

**Difficulty Curve:**
- Arena 1: Learn basics, minimal challenge
- Arena 2-3: Introduce complexity gradually
- Arena 4-5: Significant challenge
- Arena 6: Endgame mastery test

**Enemy Balance:**
- Common (weight > 20): Fodder
- Uncommon (weight 10-20): Moderate threat
- Rare (weight < 10): Significant threat

**Badge Thresholds:**
- Should be achievable by wave 6-8
- Encourage specific build choices

### 12. PULSE Adaptive Music System

The game uses a **procedural adaptive music system** (`js/systems/pulseMusic.js`). 
All audio is synthesized via Web Audio API ‚Äî **no audio files needed**.

**Full design spec:** `docs/PULSE_MUSIC_SYSTEM.md`

#### How It Works
- Each arena has a unique **musical identity** (key, scale, tempo, timbre)
- Music **layers build dynamically** based on enemy count and intensity
- Enemy sounds are **pitched to the arena's key** (diegetic audio)
- Filter cutoff responds to **player health** (low health = muffled)
- Boss fights add **sub-bass, stabs, and chaos layers**

#### Integration Points (already hooked into game loop)
```javascript
PulseMusic.onWaveStart(waveNum)      // Wave stinger
PulseMusic.onWaveClear()             // Resolution chord
PulseMusic.onBossStart(arenaId)      // Boss entrance stinger
PulseMusic.onBossDefeat()            // Victory fanfare
PulseMusic.onEnemySpawn(enemy)       // Enemy spawn sound
PulseMusic.onEnemyDeath(enemy)       // Enemy death sound
PulseMusic.onEnemyAttack(enemy)      // Enemy attack sound
PulseMusic.onPlayerDamage(healthPct) // Damage stinger
PulseMusic.onLevelUp()               // Level up chime
PulseMusic.onShieldHit()             // Metallic ping (with spam prevention)
PulseMusic.onShieldBreak()           // Impact + shatter
PulseMusic.onBossExposed()           // Harmonic resolution
PulseMusic.onTeleport(isAppearing)   // Directional whoosh
PulseMusic.onBurrowWarning()         // Sub-bass rumble (~3s)
PulseMusic.onBurrowEmerge()          // Explosive burst
PulseMusic.onWallSpawn()             // FM zap
PulseMusic.update(gameState, enemies, boss) // Called each frame
```

#### Adding New Sound Events
When adding mechanics that need audio feedback:

1. **Add a method to PulseMusic** (e.g., `onShieldBreak()`)
2. **Pitch sounds to the arena key:**
   ```javascript
   const note = this.currentProfile.rootMidi + this.currentProfile.scaleIntervals[degree];
   ```
3. **Use existing sound generators:** `playStab()`, `playGlitch()`, `playLead()`, etc.
4. **Call from game code:** `PulseMusic.onShieldBreak()`

**DO NOT** add external audio files ‚Äî the system synthesizes everything.

#### Adaptive Parameters (automatic)
| Game State | Musical Response |
|------------|------------------|
| Enemy count | Layer density (1-8 layers) |
| Player health | Filter cutoff (muffled when low) |
| Wave progress | Harmonic tension |
| Boss phase | Tempo boost, extra layers |
| Kill rate | Micro tempo variations |

### 13. Playtest Feedback System

The game includes an **in-game feedback collection system** for playtesting.

**Full setup guide:** `docs/PLAYTEST_FORM_GUIDE.md`

#### How It Works
- **Boss 1 Lockdown**: Game ends after defeating Boss 1, shows feedback overlay
- **Manual Access**: Feedback button in main menu, pause menu, and death screen
- **Data Flow**: In-game form ‚Üí Google Apps Script ‚Üí Google Sheet + Discord ping
- **Daily Sync**: GitHub Action reads sheet, posts summary comment to version thread

#### Configuration
Feedback requires `.env` (gitignored) with:
```env
PLAYTEST_URL=https://script.google.com/...
PLAYTEST_TOKEN=your-secret-token
```

#### Key Files
| File | Purpose |
|------|---------|
| `js/systems/playtestFeedback.js` | Form UI and submission logic |
| `scripts/feedback-sync.js` | GitHub Action sync script |
| `.github/workflows/feedback-sync.yml` | Daily sync workflow |
| `docs/playtests/*.md` | Auto-generated feedback summaries |

#### GitHub Thread Model
- **One issue per major.minor version** (e.g., `[Playtest] Feedback Thread - v0.2.x`)
- **Daily comments** with aggregated stats (only if new feedback)
- **Raw data** committed to `docs/playtests/YYYY-MM-DD.md`

### 14. Don'ts (IMPORTANT)

- **DON'T** add npm dependencies
- **DON'T** add additional build systems or bundlers (keep it minimal; use existing esbuild setup)
- **DON'T** use TypeScript
- **DON'T** create circular imports
- **DON'T** make early arenas too long
- **DON'T** make bosses pure damage sponges
- **DON'T** forget to dispose geometries/materials
- **DON'T** add external audio files (use PulseMusic system)
- **DON'T** call functions without importing them first
- **DON'T** ignore null/undefined return values
- **DON'T** assume 60fps - always use delta time
- **DON'T** add trigger functions without wiring their update functions
- **DON'T** modify gameState.health directly (use takeDamage)
- **DON'T** commit placeholder values that break loading
- **DON'T** leave stale TODO comments after completing work
- **DON'T** use console.log without DEBUG guard
- **DON'T** use `Date.now()` for game logic timing (use frame counters)
- **DON'T** access `children[]` by index (use named properties)
- **DON'T** trust object references in setTimeout/async callbacks
- **DON'T** write stub functions - always fully implement or don't add the code
- **DON'T** commit code with TODOs or stubs without asking the user first
- **DON'T** pollute global namespace with `window.functionName = ...` (use events or module exports)
- **DON'T** recreate geometry every frame to animate (use scale/position/rotation transforms)
- **DON'T** create caches without a clear function (memory grows unbounded across sessions)
- **DON'T** expose debug UI without guarding with DEBUG flag

### 15. Quick Commands

```bash
# Start local server
python -m http.server 8000

# Git workflow
git add -A
git commit -m "feat: description"
git push
```

### 16. Bug Prevention Checklist

These rules prevent common issues discovered during code reviews.

#### Memory Management
- **Pool frequently spawned objects** (projectiles, particles)
- **Cache shared geometries** - Don't create new `THREE.SphereGeometry` per spawn
- **Share materials when possible** - Same color/properties = same material instance
- **Dispose only non-shared resources** - Don't dispose cached/pooled geometries
- **Clear caches on game reset** - Prevent unbounded memory growth across sessions
- **Use transforms instead of recreating geometry** - Scale/position/rotation are free, geometry allocation is expensive

Example cache with clear function:
```javascript
const geometryCache = new Map();

function getCachedGeometry(key, createFn) {
    if (!geometryCache.has(key)) {
        geometryCache.set(key, createFn());
    }
    return geometryCache.get(key);
}

// MUST export and call on game reset!
export function clearGeometryCache() {
    for (const geometry of geometryCache.values()) {
        geometry.dispose();
    }
    geometryCache.clear();
}
```

Animate size changes with scale, NOT geometry recreation:
```javascript
// BAD - creates new geometry every frame (memory leak, GC pressure)
function updateGrowingRing(ring, newRadius) {
    ring.geometry.dispose();
    ring.geometry = new THREE.RingGeometry(newRadius - 0.2, newRadius + 0.2, 32);
}

// GOOD - use scale transform (free operation)
function updateGrowingRing(ring, growthScale) {
    ring.scale.setScalar(growthScale);
}
```

Example pooling pattern:
```javascript
// GOOD: Pooled projectiles
const pool = [];
const sharedGeometry = new THREE.SphereGeometry(0.15, 8, 8);

function getFromPool() {
    for (const obj of pool) {
        if (!obj.active) {
            obj.active = true;
            obj.visible = true;
            return obj;
        }
    }
    return pool[0]; // Reuse oldest if exhausted
}
```

#### Import Verification
- **Every function called must be imported** - Check imports match usage
- **Test code paths that trigger imported functions** - Not just happy path
- **When adding function calls, immediately add the import**

#### Null Safety
- **Always handle null/undefined returns** from functions
- **Add guards before using returned values:**
```javascript
// GOOD
const enemy = selectEnemy();
if (!enemy) {
    console.warn('[System] No valid enemy');
    return;
}

// BAD - will crash if selectEnemy returns null
const enemy = selectEnemy();
enemy.health -= damage;
```

#### Delta Time (Frame-Rate Independence)
- **All movement must use delta time** - Never assume 60fps
- **Pass delta through update functions:**
```javascript
// GOOD
function updateEnemy(delta) {
    enemy.position.x += enemy.speed * delta;
}

// BAD - movement speed depends on framerate
function updateEnemy() {
    enemy.position.x += enemy.speed;
}
```

#### Game Loop Timing
- **NEVER use Date.now() for game logic** - Use frame counters instead
- **All timers should be frame-based**, not wall-clock time
- **Slow-mo and lag must affect ALL game timing consistently**
```javascript
// BAD - wall-clock time breaks during slow-mo/lag
if (Date.now() - enemy.lastShot > 1000) { ... }

// GOOD - frame-based, respects time scale
enemy.shootTimer++;
if (enemy.shootTimer >= enemy.shootCooldownFrames) { ... }
```

#### Error Boundaries
- **Main game loop MUST have try/catch** - One error shouldn't crash the game
- **NEVER silently swallow errors** - Always track and recover or fail gracefully
- **Limit consecutive errors** - Stop the game if errors cascade
```javascript
// GOOD - tracks errors and recovers gracefully
function animate() {
    requestAnimationFrame(animate);
    try {
        updateGame(delta);
        gameState._errorCount = 0; // Reset on success
    } catch (error) {
        console.error('[MantaSphere] Update error:', error);
        gameState._errorCount = (gameState._errorCount || 0) + 1;
        
        if (gameState._errorCount <= 3) {
            // Attempt recovery - reset to safe state
            gameState.bossActive = false;
            console.warn(`Recovered from error (${gameState._errorCount}/3)`);
        } else {
            // Too many errors - stop to prevent corruption
            gameState.running = false;
            gameOver();
            return;
        }
    }
    render();
}

// BAD - silently continues in potentially corrupted state
try {
    updateGame(delta);
} catch (error) {
    console.error(error); // Just logs and continues - data may be corrupted!
}
```

#### Async Callback Safety
- **Capture references before async operations** - Objects may be disposed
- **Validate captured references inside callbacks**
```javascript
// BAD - player may be disposed before timeout fires
setTimeout(() => {
    player.material.color.set(0xff0000);
}, 500);

// GOOD - capture and validate
const playerRef = player;
setTimeout(() => {
    if (playerRef && playerRef.parent) {
        playerRef.material.color.set(0xff0000);
    }
}, 500);
```

#### Object Property Access
- **Use named properties, not array indices** for child objects
- **Assign references at creation time**
```javascript
// BAD - breaks if child order changes
marker.children[0].material.opacity = 0.5;
marker.children[1].scale.set(2, 2, 2);

// GOOD - explicit named references
marker.innerCircle = new THREE.Mesh(...);
marker.outerRing = new THREE.Mesh(...);
marker.add(marker.innerCircle);
marker.add(marker.outerRing);
// Later:
marker.innerCircle.material.opacity = 0.5;
```

#### System Wiring
- **trigger/update pairs must both be connected:**
  - If you add `triggerSlowMo()`, also wire `updateSlowMo()` in game loop
  - If you add `createTelegraph()`, also call `updateTelegraph()` and `cleanupTelegraph()`

#### State Mutation Routing
- **All damage must go through `takeDamage()`** - For combat stats tracking
- **All XP must go through the pickup system** - For multipliers
- **Never modify `gameState.health` directly** (except in `takeDamage`)

#### Debug Logging
- **Use the logging framework** - See Section 17 (Observability & Debug Logging)
- **DO NOT use raw console.log** - Always use `log()`, `logOnce()`, `logThrottled()` from `debugLog.js`
- **Keep console.warn/error for actual errors** - Storage failures, missing features, etc.
- **Rate-limit warnings that could spam** - Use `logThrottled()` or a "warned" flag
- **Warnings in update loops should fire once, not every frame**
```javascript
// BAD - spams console every frame
if (budget > 0 && !enemy) {
    console.warn('No affordable enemy');
}

// GOOD - warns once per occurrence
if (budget > 0 && !enemy && !gameState.waveSpawnWarned) {
    console.warn('No affordable enemy');
    gameState.waveSpawnWarned = true;
}
```

#### Debug Feature Guarding
- **Hide debug UI when DEBUG=false** - Don't expose game internals to players
- **Skip debug control setup when disabled** - Reduces attack surface
```javascript
// GOOD - debug button only visible when enabled
const debugBtn = document.getElementById('debug-btn');
if (debugBtn) {
    if (DEBUG) {
        debugBtn.addEventListener('click', showDebugMenu);
    } else {
        debugBtn.style.display = 'none';
    }
}

// Only set up debug controls when enabled
if (DEBUG) {
    setupDebugControls();
}
```

#### Module Communication
- **NEVER expose functions via `window.functionName`** - Pollutes global namespace
- **Use custom events for cross-module communication** when direct imports cause circular deps
```javascript
// BAD - exposes to console, players can cheat
window.startAtArena = startAtArena;
// Called from another module:
window.startAtArena(6); // Skip to final arena

// GOOD - event-based, no global exposure
// In main.js:
document.addEventListener('arenaSelect', (e) => {
    if (e.detail?.arena) startAtArena(e.detail.arena);
});

// In hud.js:
document.dispatchEvent(new CustomEvent('arenaSelect', { 
    detail: { arena: arenaNum } 
}));
```

#### Game Restart Cleanliness
- **Reset ALL timing state on restart** - Prevents stale values affecting new games
- **Clear caches on restart** - Prevents memory accumulation across sessions
```javascript
function restartGame() {
    resetGameState();
    resetAllEntities(scene);
    
    // Reset timing
    lastFrameTime = 0;
    
    // Clear caches
    clearEnemyGeometryCache();
    clearGeometryCache();
    
    // ... rest of restart logic
}
```

#### Feature Completeness
- **NEVER write stub functions** - Always fully implement the feature
- **If implementation is blocked, ask the user** before writing placeholder code
- **If a feature isn't ready, don't add the code path at all** - No empty functions
- **Before committing:** Search for `TODO`, `FIXME`, `STUB`, empty function bodies
- **If TODOs or stubs are found:** Ask the user if you should implement them before committing

#### Placeholders
- **Never commit placeholder values that break functionality:**
  - NO: `integrity="sha384-PLACEHOLDER"`
  - NO: `apiKey: 'TODO'`
  - YES: Remove the attribute entirely, add TODO comment
- **Test in browser before committing**

#### TODO Hygiene
- **Remove TODOs when work is complete**
- **Update comments when wiring is done** - Change "TODO: Wire into X" to "Used by: X"

#### CDN Security
- **Add SRI hashes for external scripts** (when available)
- **Use crossorigin="anonymous"** for CDN resources
- **Document how to regenerate hashes** if library is updated

### 17. Observability & Debug Logging

The game uses **loglevel** (CDN) with a thin wrapper (`js/systems/debugLog.js`) for structured debug logging.

#### When to Log
- **DO log**: State transitions, thresholds crossed, events (start/end/trigger)
- **DO NOT log**: Every frame, inside tight loops, redundant data

#### Tag Taxonomy

| Tag | Purpose |
|-----|---------|
| WAVE | Wave lifecycle, modifiers, budgets |
| SPAWN | Enemy/school spawns, choreography |
| BOSS | Boss lifecycle, phases, retreat/return |
| SCORE | Bonuses, calculations |
| STATE | State machine transitions |
| SAFETY | Caps, pauses, invariant violations |
| PERF | Performance metrics (disabled by default) |
| DEBUG | Debug menu operations, cheats |
| MUSIC | PulseMusic system events |
| PLAYTEST | Playtest feedback system |

#### Logger API

```javascript
import { log, logWarn, logOnce, logThrottled, assert } from '../systems/debugLog.js';

// Standard info log
log('BOSS', 'phase_transition', { from: 1, to: 2, hp: 500, trigger: 'threshold' });

// One-time log (deduped by key)
logOnce('boss-first-spawn', 'BOSS', 'first_spawn', { phase: 1 });

// Throttled log (max once per interval)
logThrottled('enemy-count', 1000, 'PERF', 'enemy_count', { count: 50 });

// Assertion (warns if condition is false)
assert(hp > 0, 'BOSS', 'hp_must_be_positive', { hp });
```

#### Configuration

In `js/config/constants.js`:
```javascript
export const DEBUG_CONFIG = {
    level: 'info',    // trace | debug | info | warn | error | silent
    tags: {
        WAVE: true,
        SPAWN: true,
        BOSS: true,
        // ... toggle per-tag
    }
};
```

#### Good vs Bad Examples

```javascript
// BAD - logs every frame
function updateBoss() {
    console.log('Boss HP:', boss.health);
}

// GOOD - logs on transition only
if (boss.health <= threshold && !boss.phaseTransitioned) {
    log('BOSS', 'phase_threshold', { hp: boss.health, threshold });
    boss.phaseTransitioned = true;
}

// BAD - ungated console.log
console.log('[Spawn] Enemy spawned');

// GOOD - uses logger with tag filtering
log('SPAWN', 'enemy_spawned', { type: 'grunt', pos: { x, z } });
```

#### Troubleshooting Common Issues

**Spawns feel too hard:**
1. Enable tags: `WAVE`, `SPAWN`, `SAFETY`
2. Check budget allocation at wave start
3. Look for `[SAFETY] cap_hit` or `stress_pause` events

**Boss phase desync:**
1. Enable tags: `BOSS`, `STATE`
2. Check `phase_transition` events for trigger reasons
3. Verify `retreat_trigger` fires at correct HP

**Waves softlock:**
1. Enable tags: `WAVE`, `STATE`, `SPAWN`
2. Check state machine transitions (should see `wave_clear`)
3. Look for `[SAFETY]` warnings

### 18. Version Management (Semantic Versioning)

The project follows **Semantic Versioning 2.0.0** (MAJOR.MINOR.PATCH) tracked in the `VERSION` file.

#### Version Bump Rules

**MAJOR version** (X.0.0) - Breaking changes:
- Breaking API changes to game systems (incompatible save data)
- Removal of core features or mechanics
- Major architecture rewrites that change fundamental behavior
- Changes that require players to restart progression

**MINOR version** (0.X.0) - New features (backwards compatible):
- New arenas, bosses, or enemy types
- New upgrade systems or modules
- New game modes or mechanics
- Significant feature additions that don't break existing saves
- Documentation updates for new features

**PATCH version** (0.0.X) - Bug fixes and minor improvements:
- Bug fixes that don't change behavior
- Performance optimizations
- Code cleanup and refactoring
- Documentation corrections
- Balance tweaks (enemy stats, damage values)
- Visual polish (particle effects, UI improvements)

#### When to Bump Version

**Before pushing to remote:**
1. Review all commits since last version bump
2. Determine highest severity change (MAJOR > MINOR > PATCH)
3. Run `node scripts/bump-version.js X.Y.Z` to update all version references
4. Include version bump in final commit message: `chore: bump version to X.Y.Z`

**Version Script (`scripts/bump-version.js`):**
- Single source of truth: `js/config/constants.js`
- Updates: `VERSION` file, `index.html` (loading screen, display, cache-buster)
- Usage: `node scripts/bump-version.js 0.3.0`

**Example Workflow:**
```bash
# Make changes and commit them
git commit -m "feat: add Arena 2 boss"
git commit -m "fix: correct projectile collision bug"

# Review changes and bump version
# Arena 2 boss = MINOR bump (new feature)
# Bug fix = PATCH bump
# Result: MINOR bump wins (0.1.0 ‚Üí 0.2.0)

node scripts/bump-version.js 0.2.0
git add .
git commit -m "chore: bump version to 0.2.0"
git push
```

#### Git Tagging Policy

**ALWAYS create GitHub tags when VERSION file changes.**

```bash
git tag vX.Y.Z
git push origin vX.Y.Z
```

#### Version Branch Workflow

**ALL work goes to the current version branch.** No PRs to main directly.

**AI Agent Rules**:

1. **Before ANY work**: Find version branch, base work there
   ```bash
   git branch -r | grep -E 'origin/[0-9]+\.[0-9]+\.x$'
   ```

2. **PRs always target version branch**, never main

3. **Suggest PR to main (release) when** (any trigger):
   - Task/feature explicitly requested is complete
   - Natural stopping point (end of session, context switch)
   - 5+ commits accumulated on version branch
   - Need to merge before starting dependent work
   - User asks "is it ready?" or "should we release?"
   - Stability checkpoint (bugs fixed, before new features)

4. **Do NOT suggest PR for**:
   - Every single commit
   - Minor doc fixes (batch them)
   - Work-in-progress that isn't testable

5. **Release suggestion format**:
   ```
   üöÄ **PR to main suggested**
   
   Branch: 0.3.x
   Changes since last release:
   - feat: [description]
   - fix: [description]
   - docs: [description]
   
   Version bump: 0.2.4 ‚Üí 0.3.0 (MINOR - new feature)
   
   Create PR now? [Yes / Not yet / What's missing?]
   ```

6. **If approved**, use GitHub CLI:
   ```bash
   gh pr create --base main --head 0.3.x --title "Release v0.3.0" --body "..."
   ```
   User reviews/approves on GitHub, then AI tags and creates next branch.

7. **After release**: Remind that new work targets the NEW version branch

#### Version History

See [CHANGELOG.md](CHANGELOG.md) for complete version history.

### 19. Source of Truth Policy

**Work Items (tasks, bugs, features):**
- GitHub Issues = ONLY source of truth
- DO NOT create or maintain task lists in markdown files
- DO NOT add `[ ]` checkboxes for work items in any file
- When user mentions a task, create a GitHub Issue (not a local file entry)

**Implementation State (what's built):**
- The CODE is the source of truth
- System details documented in docs/*.md (BOSS.md, ENEMIES.md, etc.)
- README.md for game overview

**Quick Capture:**
- `todo.txt` = Scratch pad only, NOT a backlog
- Triage todo.txt items into GitHub Issues, then clear todo.txt

**Forbidden Patterns:**
- NO `[ ]` checkboxes in README.md or any tracking file
- NO BACKLOG.md, FEATURES.md, PROJECT_STATE.md, or EPICS.md files
- NO duplicate task tracking across files and GitHub
- NO creating new state-tracking files
- NO committing generated audit artifacts (e.g. `PRE_COMMIT_AUDIT.md`) ‚Äî keep audits in chat, PR descriptions, or GitHub comments instead

**File Purposes:**
| File | Purpose | NOT For |
|------|---------|---------|
| GitHub Issues | Work to do | - |
| README.md | Game overview | Task tracking |
| docs/*.md | System documentation | Task tracking |
| `todo.txt` | Scratch capture | Permanent storage |
| `CONTRIBUTING.md` | Process docs | State tracking |

### 20. GitHub Issue Creation Process

When creating or commenting on GitHub Issues, AI agents must include persona-based analysis (not just the user request).

#### Required Structure for Issues/Comments

Every issue or comment created by the AI must include:

1. **User Request/Feedback** - What was reported or requested (quote if from playtest)
2. **AI Analysis** - Insights from the appropriate persona:
   - Use **Game Director** for cross-system, pillar alignment, scope decisions
   - Use **specialist persona** if issue is clearly in their domain (Boss Designer, Enemy Designer, etc.)
   - If no persona specified, provide general AI analysis
3. **Pillar Alignment** - Which game pillars this supports/threatens
4. **Recommendation** - Priority, scope, and implementation guidance

#### Issue Comment Format

When commenting on existing issues with playtest evidence:

```
**Playtest Evidence (YYYY-MM-DD)**

> [Quote from feedback]

**Director Analysis:**
[Persona-based reasoning about why this matters, pillar alignment, risks]

**Suggested Action:**
[Specific tuning or implementation guidance]

----
```

#### New Issue Format

```
## Problem
[Clear problem statement]

## Evidence
[Quotes, data, reproduction steps]

## Director Analysis
[Pillar alignment, why this matters for the game's identity, scope concerns]

## Proposed Solutions
[Options with tradeoffs]

## Acceptance Criteria
[Measurable outcomes]
```

#### Persona Selection

| Issue Type | Persona | Focus |
|------------|---------|-------|
| Cross-system, scope, pillars | Game Director | Identity, priorities |
| Boss mechanics | Boss Designer | Fairness, readability, phases |
| Enemy behavior/waves | Enemy Designer | Roles, composition, spawns |
| Arena layout | Arena Designer | Routing, geometry, hazards |
| Audio/music | Audio Designer | Pulse system, feedback |
| Balance/tuning | Game Director | Pillar tradeoffs |
| UX/readability | Playtest Evaluator | Evidence-based decisions |

### 21. Owner Authority Protocol (GitHub Issues)

**Project owner authority:** On GitHub Issues, `finalflick` is the final authority. If `finalflick` provides direction, it supersedes all prior discussion, analysis, plans, labels, and AI recommendations on that issue.

#### 21.1 What triggers this protocol

Treat any of the following as an **Owner Override Event** on a GitHub Issue:
- `finalflick` posts a comment (new direction, correction, constraint, scope change)
- `finalflick` edits the issue title/body
- `finalflick` changes labels, milestones, assignees, or issue state (open/close/reopen/lock)

If the override is a **comment**, the information in that comment is the source of truth for that issue. If the override is a **non-comment action**, assume intent changed and require clarification before proceeding.

#### 21.2 Stop-the-line rule (no further GitHub actions)

After an Owner Override Event is detected on an issue:
- **All agents must immediately pause** any further actions related to that issue on GitHub.
- **No further GitHub mutations are allowed** on that issue until `manta-warden` posts an acknowledgment comment on that issue.

Examples of blocked actions until acknowledgment:
- commenting (except the required `manta-warden` acknowledgment)
- changing labels/milestones/assignees/projects/status fields
- editing issue title/body
- linking/closing via PR descriptions, automations, or follow-up issue churn

#### 21.3 Required `manta-warden` acknowledgment (before any further work proceeds)

`manta-warden` must respond on the issue to:
- **acknowledge** the Owner Override Event
- **rectify**: restate the updated scope/priority/constraints in plain language
- **clarify**: ask targeted questions if anything is ambiguous
- **gate**: explicitly state what will happen next, and what is blocked pending answers

Use this exact structure:

```
**Owner Override Acknowledged (finalflick)**

**Observed:** [link/quote of finalflick comment or describe the owner action]

**Updated interpretation (supersedes prior thread):**
- Scope: [...]
- Priority/sequence: [...]
- Constraints/definition of done: [...]

**Clarifying questions (if needed):**
1. ...
2. ...

**Next action (after confirmation):**
- ...
```

#### 21.4 Agent behavior requirements

- **All agents**: Treat the most recent `finalflick` direction as canonical for that issue, even if it conflicts with docs, prior comments, or earlier agent analysis.
- **Non-warden agents**: Do not ‚Äúcontinue anyway‚Äù in the thread. If you are not `manta-warden`, your next step is to request/route for a `manta-warden` acknowledgment comment.
- **Conflict handling**: If `finalflick` direction conflicts with system constraints or safety rules, `manta-warden` must call it out and propose the smallest viable alternative while asking for confirmation.