# MantaSphere Development Rules

This document provides guidance for AI agents and developers working on the MantaSphere codebase.

## Game Identity

MantaSphere is an **arcade-style score runner** built on these pillars:

1. **Progressive Complexity** - Arenas teach mechanics incrementally
2. **Boss Puzzles** - Bosses test learned skills, not just HP pools
3. **Fast Loops** - Short early arenas, quick restarts
4. **Visual Progression** - Badges show investment and mastery
5. **Local Competition** - Leaderboards drive replayability

## Project Overview

Built with:
- **Three.js r134** (loaded via CDN, NOT npm)
- **Vanilla JavaScript** with ES Modules
- **No build system** - runs directly in browser

## Critical Rules

### 1. Three.js Usage

**DO NOT** install Three.js via npm. It's loaded via CDN:
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
```

**THREE is a global variable** - modules access it without importing.

**Use r134-compatible APIs only:**
- NO `CapsuleGeometry` (use cylinder + spheres)
- NO modern Three.js features not in r134

### 2. Module Architecture

All game code uses ES Modules. Import pattern:
```javascript
import { CONSTANT } from '../config/constants.js';
import { gameState } from '../core/gameState.js';
import { scene } from '../core/scene.js';
```

**Avoid circular dependencies:**
- Use getter functions for cross-module state
- Entity modules should not import each other's update functions

### 3. State Management

**Central state:** `js/core/gameState.js`
**Entity arrays:** `js/core/entities.js`
**Boss getter:** `getCurrentBoss()` from entities.js

### 4. Design Philosophy

#### Arena Design
Each arena should:
- Introduce ONE new mechanic
- Build on previous arena skills
- Have a boss that tests that mechanic

**Tiered Wave Counts:**
| Arena | Waves | Purpose |
|-------|-------|---------|
| 1 | 3 | Quick intro |
| 2 | 5 | Learn cover |
| 3 | 6 | Learn verticality |
| 4+ | 8-10 | Full challenge |

#### Boss Design
Bosses are **puzzle tests**, not bullet sponges:
- Phase 1: Core mechanic test
- Phase 2: Add arena twist
- Phase 3: Pressure test

Each boss failure should teach something.

#### Badge Design
- **Stat badges** - Earned during run, show build focus
- **Arena badges** - Persistent, show mastery
- Badges should be aspirational but achievable

### 5. Adding New Features

#### New Enemy Type
1. Add to `js/config/enemies.js`
2. Add behavior in `js/entities/enemies.js`
3. Set `minArena` to gate appearance
4. **Include roster display fields:** `tagline`, `description`, `behaviorText`

#### New Boss
1. Add to `js/config/bosses.js`
2. Add AI in `js/entities/boss.js`
3. Add arena badge in `js/config/badges.js`
4. **Include roster display fields:** `tagline`, `description`, `behaviorText`

#### Character Roster Maintenance
The roster screen (`js/ui/rosterUI.js`) dynamically reads from enemy and boss configs.

**When adding/modifying enemies or bosses, always include these display fields:**
```javascript
tagline: 'Short catchy phrase',           // Shows under name
description: 'Lore-friendly explanation', // Main description text
behaviorText: 'What it does in gameplay'  // Green behavior hint
```

**The roster auto-updates when:**
- New enemy/boss configs are added (appears as "???" until encountered)
- Display field text is changed
- Stats/colors are modified

**No separate roster file to maintain** - single source of truth in configs.

#### New Arena
1. Add to `js/config/arenas.js` with:
   - `waves` count
   - `features` array
   - `teaches` description
   - `bossLesson` description
2. Add geometry in `js/arena/generator.js`

#### New Badge
1. Add to `js/config/badges.js`
2. For stat badges: set `stat` and `threshold`
3. For arena badges: set `arena` and `persistent: true`

#### New Upgrade
1. Add to `js/config/upgrades.js`
2. Ensure stat exists in `gameState.stats`
3. Consider adding a badge for high values

### 6. Code Style

**Naming:**
- Functions: `camelCase`
- Constants: `UPPER_SNAKE_CASE`
- Config objects: `UPPER_SNAKE_CASE`

**Performance:**
- Reuse `THREE.Vector3` instances (use tempVec3 from entities.js)
- Use `.length = 0` to clear arrays
- Pool frequently created objects (projectiles, particles, enemies)
- Cache geometries by size - don't create new geometry per spawn
- Share materials when color/properties match
- Use delta time for all movement (never assume fixed framerate)

### 7. Common Patterns

**Spawn Pattern:**
```javascript
export function spawnThing(position) {
    const thing = new THREE.Mesh(geometry, material);
    thing.position.copy(position);
    scene.add(thing);
    thingsArray.push(thing);
    return thing;
}
```

**Boss AI Pattern:**
```javascript
function updateBossAI(boss) {
    if (boss.aiState === 'idle') {
        // Default behavior
        if (condition) {
            boss.aiState = 'attacking';
            boss.aiTimer = 0;
        }
    } else if (boss.aiState === 'attacking') {
        // Attack behavior
        if (boss.aiTimer > duration) {
            boss.aiState = 'idle';
        }
    }
}
```

### 8. Testing Changes

**Local server required:**
```bash
python -m http.server 8000
```

**Test checklist:**
- [ ] Game starts without errors
- [ ] Player can move and shoot
- [ ] Enemies spawn with correct behavior
- [ ] Bosses appear after final wave
- [ ] Level up menu works
- [ ] Pause/resume works
- [ ] Game over triggers correctly
- [ ] Leaderboard saves/loads
- [ ] Badges display correctly
- [ ] Arena transitions work

### 9. File Reference

| File | Purpose |
|------|---------|
| `js/main.js` | Entry point, game loop |
| `js/config/arenas.js` | Arena definitions with lore |
| `js/config/badges.js` | Badge definitions |
| `js/config/bosses.js` | Boss configurations |
| `js/config/enemies.js` | Enemy types |
| `js/core/gameState.js` | Central state |
| `js/systems/badges.js` | Badge tracking |
| `js/systems/leaderboard.js` | Score persistence |
| `js/systems/playtestFeedback.js` | In-game feedback form |
| `js/systems/pulseMusic.js` | Adaptive music system |
| `js/systems/waveSystem.js` | Wave/arena progression |
| `js/ui/hud.js` | HUD updates |
| `js/ui/leaderboardUI.js` | Leaderboard display |
| `js/ui/rosterUI.js` | Character roster (reads from enemy/boss configs) |
| `scripts/feedback-sync.js` | GitHub Action: sync feedback to issues |
| `.github/workflows/feedback-sync.yml` | Daily feedback sync workflow |

### 10. Documentation

| Doc | Purpose |
|-----|---------|
| `docs/PLAYER.md` | Player system - movement, combat, stats, controls |
| `docs/BOSS.md` | Boss system reference - all bosses, abilities, phases |
| `docs/ENEMIES.md` | Enemy roster - all enemy types, behaviors, spawn mechanics |
| `docs/ARENA.md` | Arena progression - wave system, geometry, unlocks |
| `docs/PULSE_MUSIC_SYSTEM.md` | Adaptive music system design |
| `docs/PLAYTEST_FORM_GUIDE.md` | Playtest feedback system setup |
| `PROMPTS.md` | Designer personas for feature design |
| `CONTRIBUTING.md` | Contribution guidelines and workflow |

#### Design Prompt Workflow

When working on **feature design** (not just bug fixes), follow this workflow:

1. **Start as Game Director** - Triage the request and decide how to handle it
2. **Route to specialist** (or handle directly if it's high-level/cross-system)
3. **Read current state** from the corresponding documentation
4. **Apply persona principles** to your design decisions

| Request Type | Persona | First Action |
|--------------|---------|--------------|
| **Any design question** | Game Director (first) | Triage and route |
| High-level / cross-system | Game Director | Answer directly |
| Boss fights / abilities | Boss Designer | Read `docs/BOSS.md` |
| Enemy types / waves | Enemy Designer | Read `docs/ENEMIES.md` |
| Arena layout / geometry | Arena Designer | Read `docs/ARENA.md` |
| Music / SFX / audio | Audio Designer | Read `docs/PULSE_MUSIC_SYSTEM.md` |
| Playtest feedback | Playtest Feedback Evaluator | Review feedback + docs |
| Code review / pre-commit | Code Review Auditor | Review code changes |
| Backlog / issues | Technical PM | Check GitHub Issues |

**Example:** When asked to design a new boss:
1. Read `PROMPTS.md` -> **Game Director** section (triage first)
2. Director routes to Boss Designer with context and constraints
3. Read `docs/BOSS.md` for current boss implementations
4. Adopt Boss Designer persona (fair, readable, memorable design principles)
5. Apply the design framework to the new boss

**Example:** When asked "Should we add a new game mode?":
1. Read `PROMPTS.md` -> **Game Director** section
2. Handle directly as Director (this is high-level / pillar question)
3. Evaluate against game pillars, recommend implement/defer/reject
4. If approved, route implementation details to appropriate specialists

#### Documentation Maintenance Policy

**Before making ANY code changes:**

1. **Review relevant documentation** for the feature you're modifying
   - Working on player? Read `docs/PLAYER.md`
   - Working on bosses? Read `docs/BOSS.md`
   - Working on enemies? Read `docs/ENEMIES.md`
   - Working on arenas? Read `docs/ARENA.md`
   - Working on music? Read `docs/PULSE_MUSIC_SYSTEM.md`

2. **Keep documentation in sync with code**
   - When adding/modifying features, update the corresponding docs
   - When changing behavior, update the behavior descriptions
   - When adjusting stats, update the stat tables

**Before committing changes:**

1. **Search for `TODO`, `FIXME`, `STUB`, empty function bodies** - Ask user to implement before committing
2. **Review docs for accuracy** - Check if your changes require doc updates
3. **Update affected documentation files** in the same commit as code changes

**Documentation-to-Code Mapping:**

| Code Files | Documentation |
|------------|---------------|
| `js/entities/player.js`, `js/systems/damage.js`, `js/systems/projectiles.js`, `js/config/upgrades.js` | `docs/PLAYER.md` |
| `js/config/bosses.js`, `js/entities/boss.js` | `docs/BOSS.md` |
| `js/config/enemies.js`, `js/entities/enemies.js` | `docs/ENEMIES.md` |
| `js/config/arenas.js`, `js/arena/generator.js`, `js/systems/waveSystem.js` | `docs/ARENA.md` |
| `js/systems/pulseMusic.js` | `docs/PULSE_MUSIC_SYSTEM.md` |

**Examples:**

- Adding a new player stat? Update `docs/PLAYER.md` stats table and upgrade that affects it
- Changing movement speed or dash mechanics? Update `docs/PLAYER.md` movement system section
- Adding a new boss ability? Update `docs/BOSS.md` with the ability description, cooldown, and which bosses use it
- Changing enemy spawn weights? Update `docs/ENEMIES.md` spawn weight tables
- Adjusting wave counts? Update `docs/ARENA.md` arena roster table
- Adding new sound events? Update `docs/PULSE_MUSIC_SYSTEM.md` integration points

**Rationale:** Documentation drift causes confusion and wasted time. By enforcing reviews before changes and updates before commits, we keep docs trustworthy and useful.

### 11. Balance Guidelines

**Difficulty Curve:**
- Arena 1: Learn basics, minimal challenge
- Arena 2-3: Introduce complexity gradually
- Arena 4-5: Significant challenge
- Arena 6: Endgame mastery test

**Enemy Balance:**
- Common (weight > 20): Fodder
- Uncommon (weight 10-20): Moderate threat
- Rare (weight < 10): Significant threat

**Badge Thresholds:**
- Should be achievable by wave 6-8
- Encourage specific build choices

### 12. PULSE Adaptive Music System

The game uses a **procedural adaptive music system** (`js/systems/pulseMusic.js`). 
All audio is synthesized via Web Audio API — **no audio files needed**.

**Full design spec:** `docs/PULSE_MUSIC_SYSTEM.md`

#### How It Works
- Each arena has a unique **musical identity** (key, scale, tempo, timbre)
- Music **layers build dynamically** based on enemy count and intensity
- Enemy sounds are **pitched to the arena's key** (diegetic audio)
- Filter cutoff responds to **player health** (low health = muffled)
- Boss fights add **sub-bass, stabs, and chaos layers**

#### Integration Points (already hooked into game loop)
```javascript
PulseMusic.onWaveStart(waveNum)      // Wave stinger
PulseMusic.onWaveClear()             // Resolution chord
PulseMusic.onBossStart(arenaId)      // Boss entrance stinger
PulseMusic.onBossDefeat()            // Victory fanfare
PulseMusic.onEnemySpawn(enemy)       // Enemy spawn sound
PulseMusic.onEnemyDeath(enemy)       // Enemy death sound
PulseMusic.onEnemyAttack(enemy)      // Enemy attack sound
PulseMusic.onPlayerDamage(healthPct) // Damage stinger
PulseMusic.onLevelUp()               // Level up chime
PulseMusic.onShieldHit()             // Metallic ping (with spam prevention)
PulseMusic.onShieldBreak()           // Impact + shatter
PulseMusic.onBossExposed()           // Harmonic resolution
PulseMusic.onTeleport(isAppearing)   // Directional whoosh
PulseMusic.onBurrowWarning()         // Sub-bass rumble (~3s)
PulseMusic.onBurrowEmerge()          // Explosive burst
PulseMusic.onWallSpawn()             // FM zap
PulseMusic.update(gameState, enemies, boss) // Called each frame
```

#### Adding New Sound Events
When adding mechanics that need audio feedback:

1. **Add a method to PulseMusic** (e.g., `onShieldBreak()`)
2. **Pitch sounds to the arena key:**
   ```javascript
   const note = this.currentProfile.rootMidi + this.currentProfile.scaleIntervals[degree];
   ```
3. **Use existing sound generators:** `playStab()`, `playGlitch()`, `playLead()`, etc.
4. **Call from game code:** `PulseMusic.onShieldBreak()`

**DO NOT** add external audio files — the system synthesizes everything.

#### Adaptive Parameters (automatic)
| Game State | Musical Response |
|------------|------------------|
| Enemy count | Layer density (1-8 layers) |
| Player health | Filter cutoff (muffled when low) |
| Wave progress | Harmonic tension |
| Boss phase | Tempo boost, extra layers |
| Kill rate | Micro tempo variations |

### 13. Playtest Feedback System

The game includes an **in-game feedback collection system** for playtesting.

**Full setup guide:** `docs/PLAYTEST_FORM_GUIDE.md`

#### How It Works
- **Boss 1 Lockdown**: Game ends after defeating Boss 1, shows feedback overlay
- **Manual Access**: Feedback button in main menu, pause menu, and death screen
- **Data Flow**: In-game form → Google Apps Script → Google Sheet + Discord ping
- **Daily Sync**: GitHub Action reads sheet, posts summary comment to version thread

#### Configuration
Feedback requires `js/config/debug.local.js` with:
```javascript
export const PLAYTEST_CONFIG = {
    url: 'https://script.google.com/...',
    token: 'your-secret-token'
};
```

#### Key Files
| File | Purpose |
|------|---------|
| `js/systems/playtestFeedback.js` | Form UI and submission logic |
| `scripts/feedback-sync.js` | GitHub Action sync script |
| `.github/workflows/feedback-sync.yml` | Daily sync workflow |
| `docs/playtests/*.md` | Auto-generated feedback summaries |

#### GitHub Thread Model
- **One issue per major.minor version** (e.g., `[Playtest] Feedback Thread - v0.2.x`)
- **Daily comments** with aggregated stats (only if new feedback)
- **Raw data** committed to `docs/playtests/YYYY-MM-DD.md`

### 14. Don'ts (IMPORTANT)

- **DON'T** add npm dependencies
- **DON'T** add a build system
- **DON'T** use TypeScript
- **DON'T** create circular imports
- **DON'T** make early arenas too long
- **DON'T** make bosses pure damage sponges
- **DON'T** forget to dispose geometries/materials
- **DON'T** add external audio files (use PulseMusic system)
- **DON'T** call functions without importing them first
- **DON'T** ignore null/undefined return values
- **DON'T** assume 60fps - always use delta time
- **DON'T** add trigger functions without wiring their update functions
- **DON'T** modify gameState.health directly (use takeDamage)
- **DON'T** commit placeholder values that break loading
- **DON'T** leave stale TODO comments after completing work
- **DON'T** use console.log without DEBUG guard
- **DON'T** use `Date.now()` for game logic timing (use frame counters)
- **DON'T** access `children[]` by index (use named properties)
- **DON'T** trust object references in setTimeout/async callbacks
- **DON'T** write stub functions - always fully implement or don't add the code
- **DON'T** commit code with TODOs or stubs without asking the user first
- **DON'T** pollute global namespace with `window.functionName = ...` (use events or module exports)
- **DON'T** recreate geometry every frame to animate (use scale/position/rotation transforms)
- **DON'T** create caches without a clear function (memory grows unbounded across sessions)
- **DON'T** expose debug UI without guarding with DEBUG flag

### 15. Quick Commands

```bash
# Start local server
python -m http.server 8000

# Git workflow
git add -A
git commit -m "feat: description"
git push
```

### 16. Bug Prevention Checklist

These rules prevent common issues discovered during code reviews.

#### Memory Management
- **Pool frequently spawned objects** (projectiles, particles)
- **Cache shared geometries** - Don't create new `THREE.SphereGeometry` per spawn
- **Share materials when possible** - Same color/properties = same material instance
- **Dispose only non-shared resources** - Don't dispose cached/pooled geometries
- **Clear caches on game reset** - Prevent unbounded memory growth across sessions
- **Use transforms instead of recreating geometry** - Scale/position/rotation are free, geometry allocation is expensive

Example cache with clear function:
```javascript
const geometryCache = new Map();

function getCachedGeometry(key, createFn) {
    if (!geometryCache.has(key)) {
        geometryCache.set(key, createFn());
    }
    return geometryCache.get(key);
}

// MUST export and call on game reset!
export function clearGeometryCache() {
    for (const geometry of geometryCache.values()) {
        geometry.dispose();
    }
    geometryCache.clear();
}
```

Animate size changes with scale, NOT geometry recreation:
```javascript
// BAD - creates new geometry every frame (memory leak, GC pressure)
function updateGrowingRing(ring, newRadius) {
    ring.geometry.dispose();
    ring.geometry = new THREE.RingGeometry(newRadius - 0.2, newRadius + 0.2, 32);
}

// GOOD - use scale transform (free operation)
function updateGrowingRing(ring, growthScale) {
    ring.scale.setScalar(growthScale);
}
```

Example pooling pattern:
```javascript
// GOOD: Pooled projectiles
const pool = [];
const sharedGeometry = new THREE.SphereGeometry(0.15, 8, 8);

function getFromPool() {
    for (const obj of pool) {
        if (!obj.active) {
            obj.active = true;
            obj.visible = true;
            return obj;
        }
    }
    return pool[0]; // Reuse oldest if exhausted
}
```

#### Import Verification
- **Every function called must be imported** - Check imports match usage
- **Test code paths that trigger imported functions** - Not just happy path
- **When adding function calls, immediately add the import**

#### Null Safety
- **Always handle null/undefined returns** from functions
- **Add guards before using returned values:**
```javascript
// GOOD
const enemy = selectEnemy();
if (!enemy) {
    console.warn('[System] No valid enemy');
    return;
}

// BAD - will crash if selectEnemy returns null
const enemy = selectEnemy();
enemy.health -= damage;
```

#### Delta Time (Frame-Rate Independence)
- **All movement must use delta time** - Never assume 60fps
- **Pass delta through update functions:**
```javascript
// GOOD
function updateEnemy(delta) {
    enemy.position.x += enemy.speed * delta;
}

// BAD - movement speed depends on framerate
function updateEnemy() {
    enemy.position.x += enemy.speed;
}
```

#### Game Loop Timing
- **NEVER use Date.now() for game logic** - Use frame counters instead
- **All timers should be frame-based**, not wall-clock time
- **Slow-mo and lag must affect ALL game timing consistently**
```javascript
// BAD - wall-clock time breaks during slow-mo/lag
if (Date.now() - enemy.lastShot > 1000) { ... }

// GOOD - frame-based, respects time scale
enemy.shootTimer++;
if (enemy.shootTimer >= enemy.shootCooldownFrames) { ... }
```

#### Error Boundaries
- **Main game loop MUST have try/catch** - One error shouldn't crash the game
- **NEVER silently swallow errors** - Always track and recover or fail gracefully
- **Limit consecutive errors** - Stop the game if errors cascade
```javascript
// GOOD - tracks errors and recovers gracefully
function animate() {
    requestAnimationFrame(animate);
    try {
        updateGame(delta);
        gameState._errorCount = 0; // Reset on success
    } catch (error) {
        console.error('[MantaSphere] Update error:', error);
        gameState._errorCount = (gameState._errorCount || 0) + 1;
        
        if (gameState._errorCount <= 3) {
            // Attempt recovery - reset to safe state
            gameState.bossActive = false;
            console.warn(`Recovered from error (${gameState._errorCount}/3)`);
        } else {
            // Too many errors - stop to prevent corruption
            gameState.running = false;
            gameOver();
            return;
        }
    }
    render();
}

// BAD - silently continues in potentially corrupted state
try {
    updateGame(delta);
} catch (error) {
    console.error(error); // Just logs and continues - data may be corrupted!
}
```

#### Async Callback Safety
- **Capture references before async operations** - Objects may be disposed
- **Validate captured references inside callbacks**
```javascript
// BAD - player may be disposed before timeout fires
setTimeout(() => {
    player.material.color.set(0xff0000);
}, 500);

// GOOD - capture and validate
const playerRef = player;
setTimeout(() => {
    if (playerRef && playerRef.parent) {
        playerRef.material.color.set(0xff0000);
    }
}, 500);
```

#### Object Property Access
- **Use named properties, not array indices** for child objects
- **Assign references at creation time**
```javascript
// BAD - breaks if child order changes
marker.children[0].material.opacity = 0.5;
marker.children[1].scale.set(2, 2, 2);

// GOOD - explicit named references
marker.innerCircle = new THREE.Mesh(...);
marker.outerRing = new THREE.Mesh(...);
marker.add(marker.innerCircle);
marker.add(marker.outerRing);
// Later:
marker.innerCircle.material.opacity = 0.5;
```

#### System Wiring
- **trigger/update pairs must both be connected:**
  - If you add `triggerSlowMo()`, also wire `updateSlowMo()` in game loop
  - If you add `createTelegraph()`, also call `updateTelegraph()` and `cleanupTelegraph()`

#### State Mutation Routing
- **All damage must go through `takeDamage()`** - For combat stats tracking
- **All XP must go through the pickup system** - For multipliers
- **Never modify `gameState.health` directly** (except in `takeDamage`)

#### Debug Logging
- **Gate all console.log behind DEBUG flag:**
```javascript
import { DEBUG } from '../config/constants.js';
if (DEBUG) console.log('[System] Message');
```
- **Keep console.warn for actual error conditions** - These should always log
- **Rate-limit warnings that could spam** - Use a "warned" flag
- **Warnings in update loops should fire once, not every frame**
```javascript
// BAD - spams console every frame
if (budget > 0 && !enemy) {
    console.warn('No affordable enemy');
}

// GOOD - warns once per occurrence
if (budget > 0 && !enemy && !gameState.waveSpawnWarned) {
    console.warn('No affordable enemy');
    gameState.waveSpawnWarned = true;
}
```

#### Debug Feature Guarding
- **Hide debug UI when DEBUG=false** - Don't expose game internals to players
- **Skip debug control setup when disabled** - Reduces attack surface
```javascript
// GOOD - debug button only visible when enabled
const debugBtn = document.getElementById('debug-btn');
if (debugBtn) {
    if (DEBUG) {
        debugBtn.addEventListener('click', showDebugMenu);
    } else {
        debugBtn.style.display = 'none';
    }
}

// Only set up debug controls when enabled
if (DEBUG) {
    setupDebugControls();
}
```

#### Module Communication
- **NEVER expose functions via `window.functionName`** - Pollutes global namespace
- **Use custom events for cross-module communication** when direct imports cause circular deps
```javascript
// BAD - exposes to console, players can cheat
window.startAtArena = startAtArena;
// Called from another module:
window.startAtArena(6); // Skip to final arena

// GOOD - event-based, no global exposure
// In main.js:
document.addEventListener('arenaSelect', (e) => {
    if (e.detail?.arena) startAtArena(e.detail.arena);
});

// In hud.js:
document.dispatchEvent(new CustomEvent('arenaSelect', { 
    detail: { arena: arenaNum } 
}));
```

#### Game Restart Cleanliness
- **Reset ALL timing state on restart** - Prevents stale values affecting new games
- **Clear caches on restart** - Prevents memory accumulation across sessions
```javascript
function restartGame() {
    resetGameState();
    resetAllEntities(scene);
    
    // Reset timing
    lastFrameTime = 0;
    
    // Clear caches
    clearEnemyGeometryCache();
    clearGeometryCache();
    
    // ... rest of restart logic
}
```

#### Feature Completeness
- **NEVER write stub functions** - Always fully implement the feature
- **If implementation is blocked, ask the user** before writing placeholder code
- **If a feature isn't ready, don't add the code path at all** - No empty functions
- **Before committing:** Search for `TODO`, `FIXME`, `STUB`, empty function bodies
- **If TODOs or stubs are found:** Ask the user if you should implement them before committing

#### Placeholders
- **Never commit placeholder values that break functionality:**
  - NO: `integrity="sha384-PLACEHOLDER"`
  - NO: `apiKey: 'TODO'`
  - YES: Remove the attribute entirely, add TODO comment
- **Test in browser before committing**

#### TODO Hygiene
- **Remove TODOs when work is complete**
- **Update comments when wiring is done** - Change "TODO: Wire into X" to "Used by: X"

#### CDN Security
- **Add SRI hashes for external scripts** (when available)
- **Use crossorigin="anonymous"** for CDN resources
- **Document how to regenerate hashes** if library is updated

### 17. Observability & Debug Logging

The game uses **loglevel** (CDN) with a thin wrapper (`js/systems/debugLog.js`) for structured debug logging.

#### When to Log
- **DO log**: State transitions, thresholds crossed, events (start/end/trigger)
- **DO NOT log**: Every frame, inside tight loops, redundant data

#### Tag Taxonomy

| Tag | Purpose |
|-----|---------|
| WAVE | Wave lifecycle, modifiers, budgets |
| SPAWN | Enemy/school spawns, choreography |
| BOSS | Boss lifecycle, phases, retreat/return |
| SCORE | Bonuses, calculations |
| STATE | State machine transitions |
| SAFETY | Caps, pauses, invariant violations |
| PERF | Performance metrics (disabled by default) |

#### Logger API

```javascript
import { log, logWarn, logOnce, logThrottled, assert } from '../systems/debugLog.js';

// Standard info log
log('BOSS', 'phase_transition', { from: 1, to: 2, hp: 500, trigger: 'threshold' });

// One-time log (deduped by key)
logOnce('boss-first-spawn', 'BOSS', 'first_spawn', { phase: 1 });

// Throttled log (max once per interval)
logThrottled('enemy-count', 1000, 'PERF', 'enemy_count', { count: 50 });

// Assertion (warns if condition is false)
assert(hp > 0, 'BOSS', 'hp_must_be_positive', { hp });
```

#### Configuration

In `js/config/constants.js`:
```javascript
export const DEBUG_CONFIG = {
    level: 'info',    // trace | debug | info | warn | error | silent
    tags: {
        WAVE: true,
        SPAWN: true,
        BOSS: true,
        // ... toggle per-tag
    }
};
```

#### Good vs Bad Examples

```javascript
// BAD - logs every frame
function updateBoss() {
    console.log('Boss HP:', boss.health);
}

// GOOD - logs on transition only
if (boss.health <= threshold && !boss.phaseTransitioned) {
    log('BOSS', 'phase_threshold', { hp: boss.health, threshold });
    boss.phaseTransitioned = true;
}

// BAD - ungated console.log
console.log('[Spawn] Enemy spawned');

// GOOD - uses logger with tag filtering
log('SPAWN', 'enemy_spawned', { type: 'grunt', pos: { x, z } });
```

#### Troubleshooting Common Issues

**Spawns feel too hard:**
1. Enable tags: `WAVE`, `SPAWN`, `SAFETY`
2. Check budget allocation at wave start
3. Look for `[SAFETY] cap_hit` or `stress_pause` events

**Boss phase desync:**
1. Enable tags: `BOSS`, `STATE`
2. Check `phase_transition` events for trigger reasons
3. Verify `retreat_trigger` fires at correct HP

**Waves softlock:**
1. Enable tags: `WAVE`, `STATE`, `SPAWN`
2. Check state machine transitions (should see `wave_clear`)
3. Look for `[SAFETY]` warnings

### 18. Version Management (Semantic Versioning)

The project follows **Semantic Versioning 2.0.0** (MAJOR.MINOR.PATCH) tracked in the `VERSION` file.

#### Version Bump Rules

**MAJOR version** (X.0.0) - Breaking changes:
- Breaking API changes to game systems (incompatible save data)
- Removal of core features or mechanics
- Major architecture rewrites that change fundamental behavior
- Changes that require players to restart progression

**MINOR version** (0.X.0) - New features (backwards compatible):
- New arenas, bosses, or enemy types
- New upgrade systems or modules
- New game modes or mechanics
- Significant feature additions that don't break existing saves
- Documentation updates for new features

**PATCH version** (0.0.X) - Bug fixes and minor improvements:
- Bug fixes that don't change behavior
- Performance optimizations
- Code cleanup and refactoring
- Documentation corrections
- Balance tweaks (enemy stats, damage values)
- Visual polish (particle effects, UI improvements)

#### When to Bump Version

**Before pushing to remote:**
1. Review all commits since last version bump
2. Determine highest severity change (MAJOR > MINOR > PATCH)
3. Run `node scripts/bump-version.js X.Y.Z` to update all version references
4. Include version bump in final commit message: `chore: bump version to X.Y.Z`

**Version Script (`scripts/bump-version.js`):**
- Single source of truth: `js/config/constants.js`
- Updates: `VERSION` file, `index.html` (loading screen, display, cache-buster)
- Usage: `node scripts/bump-version.js 0.3.0`

**Example Workflow:**
```bash
# Make changes and commit them
git commit -m "feat: add Arena 2 boss"
git commit -m "fix: correct projectile collision bug"

# Review changes and bump version
# Arena 2 boss = MINOR bump (new feature)
# Bug fix = PATCH bump
# Result: MINOR bump wins (0.1.0 → 0.2.0)

node scripts/bump-version.js 0.2.0
git add .
git commit -m "chore: bump version to 0.2.0"
git push
```

#### Version History

See [CHANGELOG.md](CHANGELOG.md) for complete version history.

### 19. Source of Truth Policy

**Work Items (tasks, bugs, features):**
- GitHub Issues = ONLY source of truth
- DO NOT create or maintain task lists in markdown files
- DO NOT add `[ ]` checkboxes for work items in any file
- When user mentions a task, create a GitHub Issue (not a local file entry)

**Implementation State (what's built):**
- The CODE is the source of truth
- System details documented in docs/*.md (BOSS.md, ENEMIES.md, etc.)
- README.md for game overview

**Quick Capture:**
- `todo.txt` = Scratch pad only, NOT a backlog
- Triage todo.txt items into GitHub Issues, then clear todo.txt

**Forbidden Patterns:**
- NO `[ ]` checkboxes in README.md or any tracking file
- NO BACKLOG.md, FEATURES.md, PROJECT_STATE.md, or EPICS.md files
- NO duplicate task tracking across files and GitHub
- NO creating new state-tracking files

**File Purposes:**
| File | Purpose | NOT For |
|------|---------|---------|
| GitHub Issues | Work to do | - |
| README.md | Game overview | Task tracking |
| docs/*.md | System documentation | Task tracking |
| `todo.txt` | Scratch capture | Permanent storage |
| `CONTRIBUTING.md` | Process docs | State tracking |
