# MantaSphere Development Rules

This document provides guidance for AI agents and developers working on the MantaSphere codebase.

## Game Identity

MantaSphere is an **arcade-style score runner** built on these pillars:

1. **Progressive Complexity** - Arenas teach mechanics incrementally
2. **Boss Puzzles** - Bosses test learned skills, not just HP pools
3. **Fast Loops** - Short early arenas, quick restarts
4. **Visual Progression** - Badges show investment and mastery
5. **Local Competition** - Leaderboards drive replayability

## Project Overview

Built with:
- **Three.js r134** (loaded via CDN, NOT npm)
- **Vanilla JavaScript** with ES Modules
- **No build system** - runs directly in browser

## Critical Rules

### 1. Three.js Usage

**DO NOT** install Three.js via npm. It's loaded via CDN:
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
```

**THREE is a global variable** - modules access it without importing.

**Use r134-compatible APIs only:**
- NO `CapsuleGeometry` (use cylinder + spheres)
- NO modern Three.js features not in r134

### 2. Module Architecture

All game code uses ES Modules. Import pattern:
```javascript
import { CONSTANT } from '../config/constants.js';
import { gameState } from '../core/gameState.js';
import { scene } from '../core/scene.js';
```

**Avoid circular dependencies:**
- Use getter functions for cross-module state
- Entity modules should not import each other's update functions

### 3. State Management

**Central state:** `js/core/gameState.js`
**Entity arrays:** `js/core/entities.js`
**Boss getter:** `getCurrentBoss()` from entities.js

### 4. Design Philosophy

#### Arena Design
Each arena should:
- Introduce ONE new mechanic
- Build on previous arena skills
- Have a boss that tests that mechanic

**Tiered Wave Counts:**
| Arena | Waves | Purpose |
|-------|-------|---------|
| 1 | 3 | Quick intro |
| 2 | 5 | Learn cover |
| 3 | 6 | Learn verticality |
| 4+ | 8-10 | Full challenge |

#### Boss Design
Bosses are **puzzle tests**, not bullet sponges:
- Phase 1: Core mechanic test
- Phase 2: Add arena twist
- Phase 3: Pressure test

Each boss failure should teach something.

#### Badge Design
- **Stat badges** - Earned during run, show build focus
- **Arena badges** - Persistent, show mastery
- Badges should be aspirational but achievable

### 5. Adding New Features

#### New Enemy Type
1. Add to `js/config/enemies.js`
2. Add behavior in `js/entities/enemies.js`
3. Set `minArena` to gate appearance
4. **Include roster display fields:** `tagline`, `description`, `behaviorText`

#### New Boss
1. Add to `js/config/bosses.js`
2. Add AI in `js/entities/boss.js`
3. Add arena badge in `js/config/badges.js`
4. **Include roster display fields:** `tagline`, `description`, `behaviorText`

#### Character Roster Maintenance
The roster screen (`js/ui/rosterUI.js`) dynamically reads from enemy and boss configs.

**When adding/modifying enemies or bosses, always include these display fields:**
```javascript
tagline: 'Short catchy phrase',           // Shows under name
description: 'Lore-friendly explanation', // Main description text
behaviorText: 'What it does in gameplay'  // Green behavior hint
```

**The roster auto-updates when:**
- New enemy/boss configs are added (appears as "???" until encountered)
- Display field text is changed
- Stats/colors are modified

**No separate roster file to maintain** - single source of truth in configs.

#### New Arena
1. Add to `js/config/arenas.js` with:
   - `waves` count
   - `features` array
   - `teaches` description
   - `bossLesson` description
2. Add geometry in `js/arena/generator.js`

#### New Badge
1. Add to `js/config/badges.js`
2. For stat badges: set `stat` and `threshold`
3. For arena badges: set `arena` and `persistent: true`

#### New Upgrade
1. Add to `js/config/upgrades.js`
2. Ensure stat exists in `gameState.stats`
3. Consider adding a badge for high values

### 6. Code Style

**Naming:**
- Functions: `camelCase`
- Constants: `UPPER_SNAKE_CASE`
- Config objects: `UPPER_SNAKE_CASE`

**Performance:**
- Reuse `THREE.Vector3` instances (use tempVec3 from entities.js)
- Use `.length = 0` to clear arrays
- Pool frequently created objects (projectiles, particles, enemies)
- Cache geometries by size - don't create new geometry per spawn
- Share materials when color/properties match
- Use delta time for all movement (never assume fixed framerate)

### 7. Common Patterns

**Spawn Pattern:**
```javascript
export function spawnThing(position) {
    const thing = new THREE.Mesh(geometry, material);
    thing.position.copy(position);
    scene.add(thing);
    thingsArray.push(thing);
    return thing;
}
```

**Boss AI Pattern:**
```javascript
function updateBossAI(boss) {
    if (boss.aiState === 'idle') {
        // Default behavior
        if (condition) {
            boss.aiState = 'attacking';
            boss.aiTimer = 0;
        }
    } else if (boss.aiState === 'attacking') {
        // Attack behavior
        if (boss.aiTimer > duration) {
            boss.aiState = 'idle';
        }
    }
}
```

### 8. Testing Changes

**Local server required:**
```bash
python -m http.server 8000
```

**Test checklist:**
- [ ] Game starts without errors
- [ ] Player can move and shoot
- [ ] Enemies spawn with correct behavior
- [ ] Bosses appear after final wave
- [ ] Level up menu works
- [ ] Pause/resume works
- [ ] Game over triggers correctly
- [ ] Leaderboard saves/loads
- [ ] Badges display correctly
- [ ] Arena transitions work

### 9. File Reference

| File | Purpose |
|------|---------|
| `js/main.js` | Entry point, game loop |
| `js/config/arenas.js` | Arena definitions with lore |
| `js/config/badges.js` | Badge definitions |
| `js/config/bosses.js` | Boss configurations |
| `js/config/enemies.js` | Enemy types |
| `js/core/gameState.js` | Central state |
| `js/systems/badges.js` | Badge tracking |
| `js/systems/leaderboard.js` | Score persistence |
| `js/systems/pulseMusic.js` | Adaptive music system |
| `js/systems/waveSystem.js` | Wave/arena progression |
| `js/ui/hud.js` | HUD updates |
| `js/ui/leaderboardUI.js` | Leaderboard display |
| `js/ui/rosterUI.js` | Character roster (reads from enemy/boss configs) |

### 10. Documentation

| Doc | Purpose |
|-----|---------|
| `docs/PLAYER.md` | Player system - movement, combat, stats, controls |
| `docs/BOSS.md` | Boss system reference - all bosses, abilities, phases |
| `docs/ENEMIES.md` | Enemy roster - all enemy types, behaviors, spawn mechanics |
| `docs/ARENA.md` | Arena progression - wave system, geometry, unlocks |
| `docs/EPICS.md` | Feature tracking and epic status |
| `docs/PROJECT_STATE.md` | Current implementation state and known issues |
| `docs/PULSE_MUSIC_SYSTEM.md` | Adaptive music system design |
| `PROMPTS.md` | Designer personas for feature design |
| `FEATURES.md` | Complete feature list with checkboxes |

#### Design Prompt Workflow

When working on **feature design** (not just bug fixes), follow this workflow:

1. **Load the designer persona** from `PROMPTS.md` for the feature area
2. **Read current state** from the corresponding documentation
3. **Apply persona principles** to your design decisions

| Feature Area | Persona | State Doc |
|--------------|---------|-----------|
| Boss fights | Boss Designer | `docs/BOSS.md` |
| Enemy types | Enemy Designer | `docs/ENEMIES.md` |
| Arena design | Arena Designer | `docs/ARENA.md` |
| Music/Audio | Audio Designer | `docs/PULSE_MUSIC_SYSTEM.md` |

**Example:** When asked to design a new boss:
1. Read `PROMPTS.md` -> Boss Designer section
2. Adopt the persona (fair, readable, memorable design principles)
3. Read `docs/BOSS.md` for current boss implementations
4. Apply the design framework to the new boss

#### Documentation Maintenance Policy

**Before making ANY code changes:**

1. **Review relevant documentation** for the feature you're modifying
   - Working on player? Read `docs/PLAYER.md`
   - Working on bosses? Read `docs/BOSS.md`
   - Working on enemies? Read `docs/ENEMIES.md`
   - Working on arenas? Read `docs/ARENA.md`
   - Working on music? Read `docs/PULSE_MUSIC_SYSTEM.md`

2. **Keep documentation in sync with code**
   - When adding/modifying features, update the corresponding docs
   - When changing behavior, update the behavior descriptions
   - When adjusting stats, update the stat tables

**Before committing changes:**

1. **Search for `TODO`, `FIXME`, `STUB`, empty function bodies** - Ask user to implement before committing
2. **Review docs for accuracy** - Check if your changes require doc updates
3. **Update affected documentation files** in the same commit as code changes
4. Update `docs/EPICS.md` if feature/epic status changed
5. Update `docs/PROJECT_STATE.md` if behavior or architecture changed
6. Update `FEATURES.md` if adding/completing features

**Documentation-to-Code Mapping:**

| Code Files | Documentation |
|------------|---------------|
| `js/entities/player.js`, `js/systems/damage.js`, `js/systems/projectiles.js`, `js/config/upgrades.js` | `docs/PLAYER.md` |
| `js/config/bosses.js`, `js/entities/boss.js` | `docs/BOSS.md` |
| `js/config/enemies.js`, `js/entities/enemies.js` | `docs/ENEMIES.md` |
| `js/config/arenas.js`, `js/arena/generator.js`, `js/systems/waveSystem.js` | `docs/ARENA.md` |
| `js/systems/pulseMusic.js` | `docs/PULSE_MUSIC_SYSTEM.md` |
| Feature tracking, epic status | `docs/EPICS.md` |
| Implementation state, known issues | `docs/PROJECT_STATE.md` |

**Examples:**

- Adding a new player stat? Update `docs/PLAYER.md` stats table and upgrade that affects it
- Changing movement speed or dash mechanics? Update `docs/PLAYER.md` movement system section
- Adding a new boss ability? Update `docs/BOSS.md` with the ability description, cooldown, and which bosses use it
- Changing enemy spawn weights? Update `docs/ENEMIES.md` spawn weight tables
- Adjusting wave counts? Update `docs/ARENA.md` arena roster table
- Adding new sound events? Update `docs/PULSE_MUSIC_SYSTEM.md` integration points

**Rationale:** Documentation drift causes confusion and wasted time. By enforcing reviews before changes and updates before commits, we keep docs trustworthy and useful.

### 11. Balance Guidelines

**Difficulty Curve:**
- Arena 1: Learn basics, minimal challenge
- Arena 2-3: Introduce complexity gradually
- Arena 4-5: Significant challenge
- Arena 6: Endgame mastery test

**Enemy Balance:**
- Common (weight > 20): Fodder
- Uncommon (weight 10-20): Moderate threat
- Rare (weight < 10): Significant threat

**Badge Thresholds:**
- Should be achievable by wave 6-8
- Encourage specific build choices

### 12. PULSE Adaptive Music System

The game uses a **procedural adaptive music system** (`js/systems/pulseMusic.js`). 
All audio is synthesized via Web Audio API — **no audio files needed**.

**Full design spec:** `docs/PULSE_MUSIC_SYSTEM.md`

#### How It Works
- Each arena has a unique **musical identity** (key, scale, tempo, timbre)
- Music **layers build dynamically** based on enemy count and intensity
- Enemy sounds are **pitched to the arena's key** (diegetic audio)
- Filter cutoff responds to **player health** (low health = muffled)
- Boss fights add **sub-bass, stabs, and chaos layers**

#### Integration Points (already hooked into game loop)
```javascript
PulseMusic.onWaveStart(waveNum)      // Wave stinger
PulseMusic.onWaveClear()             // Resolution chord
PulseMusic.onBossStart(arenaId)      // Boss entrance stinger
PulseMusic.onBossDefeat()            // Victory fanfare
PulseMusic.onEnemySpawn(enemy)       // Enemy spawn sound
PulseMusic.onEnemyDeath(enemy)       // Enemy death sound
PulseMusic.onEnemyAttack(enemy)      // Enemy attack sound
PulseMusic.onPlayerDamage(healthPct) // Damage stinger
PulseMusic.onLevelUp()               // Level up chime
PulseMusic.onShieldHit()             // Metallic ping (with spam prevention)
PulseMusic.onShieldBreak()           // Impact + shatter
PulseMusic.onBossExposed()           // Harmonic resolution
PulseMusic.onTeleport(isAppearing)   // Directional whoosh
PulseMusic.onBurrowWarning()         // Sub-bass rumble (~3s)
PulseMusic.onBurrowEmerge()          // Explosive burst
PulseMusic.onWallSpawn()             // FM zap
PulseMusic.update(gameState, enemies, boss) // Called each frame
```

#### Adding New Sound Events
When adding mechanics that need audio feedback:

1. **Add a method to PulseMusic** (e.g., `onShieldBreak()`)
2. **Pitch sounds to the arena key:**
   ```javascript
   const note = this.currentProfile.rootMidi + this.currentProfile.scaleIntervals[degree];
   ```
3. **Use existing sound generators:** `playStab()`, `playGlitch()`, `playLead()`, etc.
4. **Call from game code:** `PulseMusic.onShieldBreak()`

**DO NOT** add external audio files — the system synthesizes everything.

#### Adaptive Parameters (automatic)
| Game State | Musical Response |
|------------|------------------|
| Enemy count | Layer density (1-8 layers) |
| Player health | Filter cutoff (muffled when low) |
| Wave progress | Harmonic tension |
| Boss phase | Tempo boost, extra layers |
| Kill rate | Micro tempo variations |

### 13. Don'ts

- **DON'T** add npm dependencies
- **DON'T** add a build system
- **DON'T** use TypeScript
- **DON'T** create circular imports
- **DON'T** make early arenas too long
- **DON'T** make bosses pure damage sponges
- **DON'T** forget to dispose geometries/materials
- **DON'T** add external audio files (use PulseMusic system)
- **DON'T** call functions without importing them first
- **DON'T** ignore null/undefined return values
- **DON'T** assume 60fps - always use delta time
- **DON'T** add trigger functions without wiring their update functions
- **DON'T** modify gameState.health directly (use takeDamage)
- **DON'T** commit placeholder values that break loading
- **DON'T** leave stale TODO comments after completing work
- **DON'T** use console.log without DEBUG guard
- **DON'T** use `Date.now()` for game logic timing (use frame counters)
- **DON'T** access `children[]` by index (use named properties)
- **DON'T** trust object references in setTimeout/async callbacks
- **DON'T** write stub functions - always fully implement or don't add the code
- **DON'T** commit code with TODOs or stubs without asking the user first
- **DON'T** pollute global namespace with `window.functionName = ...` (use events or module exports)
- **DON'T** recreate geometry every frame to animate (use scale/position/rotation transforms)
- **DON'T** create caches without a clear function (memory grows unbounded across sessions)
- **DON'T** expose debug UI without guarding with DEBUG flag

### 14. Quick Commands

```bash
# Start local server
python -m http.server 8000

# Git workflow
git add -A
git commit -m "feat: description"
git push
```

### 15. Bug Prevention Checklist

These rules prevent common issues discovered during code reviews.

#### Memory Management
- **Pool frequently spawned objects** (projectiles, particles)
- **Cache shared geometries** - Don't create new `THREE.SphereGeometry` per spawn
- **Share materials when possible** - Same color/properties = same material instance
- **Dispose only non-shared resources** - Don't dispose cached/pooled geometries
- **Clear caches on game reset** - Prevent unbounded memory growth across sessions
- **Use transforms instead of recreating geometry** - Scale/position/rotation are free, geometry allocation is expensive

Example cache with clear function:
```javascript
const geometryCache = new Map();

function getCachedGeometry(key, createFn) {
    if (!geometryCache.has(key)) {
        geometryCache.set(key, createFn());
    }
    return geometryCache.get(key);
}

// MUST export and call on game reset!
export function clearGeometryCache() {
    for (const geometry of geometryCache.values()) {
        geometry.dispose();
    }
    geometryCache.clear();
}
```

Animate size changes with scale, NOT geometry recreation:
```javascript
// BAD - creates new geometry every frame (memory leak, GC pressure)
function updateGrowingRing(ring, newRadius) {
    ring.geometry.dispose();
    ring.geometry = new THREE.RingGeometry(newRadius - 0.2, newRadius + 0.2, 32);
}

// GOOD - use scale transform (free operation)
function updateGrowingRing(ring, growthScale) {
    ring.scale.setScalar(growthScale);
}
```

Example pooling pattern:
```javascript
// GOOD: Pooled projectiles
const pool = [];
const sharedGeometry = new THREE.SphereGeometry(0.15, 8, 8);

function getFromPool() {
    for (const obj of pool) {
        if (!obj.active) {
            obj.active = true;
            obj.visible = true;
            return obj;
        }
    }
    return pool[0]; // Reuse oldest if exhausted
}
```

#### Import Verification
- **Every function called must be imported** - Check imports match usage
- **Test code paths that trigger imported functions** - Not just happy path
- **When adding function calls, immediately add the import**

#### Null Safety
- **Always handle null/undefined returns** from functions
- **Add guards before using returned values:**
```javascript
// GOOD
const enemy = selectEnemy();
if (!enemy) {
    console.warn('[System] No valid enemy');
    return;
}

// BAD - will crash if selectEnemy returns null
const enemy = selectEnemy();
enemy.health -= damage;
```

#### Delta Time (Frame-Rate Independence)
- **All movement must use delta time** - Never assume 60fps
- **Pass delta through update functions:**
```javascript
// GOOD
function updateEnemy(delta) {
    enemy.position.x += enemy.speed * delta;
}

// BAD - movement speed depends on framerate
function updateEnemy() {
    enemy.position.x += enemy.speed;
}
```

#### Game Loop Timing
- **NEVER use Date.now() for game logic** - Use frame counters instead
- **All timers should be frame-based**, not wall-clock time
- **Slow-mo and lag must affect ALL game timing consistently**
```javascript
// BAD - wall-clock time breaks during slow-mo/lag
if (Date.now() - enemy.lastShot > 1000) { ... }

// GOOD - frame-based, respects time scale
enemy.shootTimer++;
if (enemy.shootTimer >= enemy.shootCooldownFrames) { ... }
```

#### Error Boundaries
- **Main game loop MUST have try/catch** - One error shouldn't crash the game
- **NEVER silently swallow errors** - Always track and recover or fail gracefully
- **Limit consecutive errors** - Stop the game if errors cascade
```javascript
// GOOD - tracks errors and recovers gracefully
function animate() {
    requestAnimationFrame(animate);
    try {
        updateGame(delta);
        gameState._errorCount = 0; // Reset on success
    } catch (error) {
        console.error('[MantaSphere] Update error:', error);
        gameState._errorCount = (gameState._errorCount || 0) + 1;
        
        if (gameState._errorCount <= 3) {
            // Attempt recovery - reset to safe state
            gameState.bossActive = false;
            console.warn(`Recovered from error (${gameState._errorCount}/3)`);
        } else {
            // Too many errors - stop to prevent corruption
            gameState.running = false;
            gameOver();
            return;
        }
    }
    render();
}

// BAD - silently continues in potentially corrupted state
try {
    updateGame(delta);
} catch (error) {
    console.error(error); // Just logs and continues - data may be corrupted!
}
```

#### Async Callback Safety
- **Capture references before async operations** - Objects may be disposed
- **Validate captured references inside callbacks**
```javascript
// BAD - player may be disposed before timeout fires
setTimeout(() => {
    player.material.color.set(0xff0000);
}, 500);

// GOOD - capture and validate
const playerRef = player;
setTimeout(() => {
    if (playerRef && playerRef.parent) {
        playerRef.material.color.set(0xff0000);
    }
}, 500);
```

#### Object Property Access
- **Use named properties, not array indices** for child objects
- **Assign references at creation time**
```javascript
// BAD - breaks if child order changes
marker.children[0].material.opacity = 0.5;
marker.children[1].scale.set(2, 2, 2);

// GOOD - explicit named references
marker.innerCircle = new THREE.Mesh(...);
marker.outerRing = new THREE.Mesh(...);
marker.add(marker.innerCircle);
marker.add(marker.outerRing);
// Later:
marker.innerCircle.material.opacity = 0.5;
```

#### System Wiring
- **trigger/update pairs must both be connected:**
  - If you add `triggerSlowMo()`, also wire `updateSlowMo()` in game loop
  - If you add `createTelegraph()`, also call `updateTelegraph()` and `cleanupTelegraph()`

#### State Mutation Routing
- **All damage must go through `takeDamage()`** - For combat stats tracking
- **All XP must go through the pickup system** - For multipliers
- **Never modify `gameState.health` directly** (except in `takeDamage`)

#### Debug Logging
- **Gate all console.log behind DEBUG flag:**
```javascript
import { DEBUG } from '../config/constants.js';
if (DEBUG) console.log('[System] Message');
```
- **Keep console.warn for actual error conditions** - These should always log
- **Rate-limit warnings that could spam** - Use a "warned" flag
- **Warnings in update loops should fire once, not every frame**
```javascript
// BAD - spams console every frame
if (budget > 0 && !enemy) {
    console.warn('No affordable enemy');
}

// GOOD - warns once per occurrence
if (budget > 0 && !enemy && !gameState.waveSpawnWarned) {
    console.warn('No affordable enemy');
    gameState.waveSpawnWarned = true;
}
```

#### Debug Feature Guarding
- **Hide debug UI when DEBUG=false** - Don't expose game internals to players
- **Skip debug control setup when disabled** - Reduces attack surface
```javascript
// GOOD - debug button only visible when enabled
const debugBtn = document.getElementById('debug-btn');
if (debugBtn) {
    if (DEBUG) {
        debugBtn.addEventListener('click', showDebugMenu);
    } else {
        debugBtn.style.display = 'none';
    }
}

// Only set up debug controls when enabled
if (DEBUG) {
    setupDebugControls();
}
```

#### Module Communication
- **NEVER expose functions via `window.functionName`** - Pollutes global namespace
- **Use custom events for cross-module communication** when direct imports cause circular deps
```javascript
// BAD - exposes to console, players can cheat
window.startAtArena = startAtArena;
// Called from another module:
window.startAtArena(6); // Skip to final arena

// GOOD - event-based, no global exposure
// In main.js:
document.addEventListener('arenaSelect', (e) => {
    if (e.detail?.arena) startAtArena(e.detail.arena);
});

// In hud.js:
document.dispatchEvent(new CustomEvent('arenaSelect', { 
    detail: { arena: arenaNum } 
}));
```

#### Game Restart Cleanliness
- **Reset ALL timing state on restart** - Prevents stale values affecting new games
- **Clear caches on restart** - Prevents memory accumulation across sessions
```javascript
function restartGame() {
    resetGameState();
    resetAllEntities(scene);
    
    // Reset timing
    lastFrameTime = 0;
    
    // Clear caches
    clearEnemyGeometryCache();
    clearGeometryCache();
    
    // ... rest of restart logic
}
```

#### Feature Completeness
- **NEVER write stub functions** - Always fully implement the feature
- **If implementation is blocked, ask the user** before writing placeholder code
- **If a feature isn't ready, don't add the code path at all** - No empty functions
- **Before committing:** Search for `TODO`, `FIXME`, `STUB`, empty function bodies
- **If TODOs or stubs are found:** Ask the user if you should implement them before committing

#### Placeholders
- **Never commit placeholder values that break functionality:**
  - NO: `integrity="sha384-PLACEHOLDER"`
  - NO: `apiKey: 'TODO'`
  - YES: Remove the attribute entirely, add TODO comment
- **Test in browser before committing**

#### TODO Hygiene
- **Remove TODOs when work is complete**
- **Update comments when wiring is done** - Change "TODO: Wire into X" to "Used by: X"

#### CDN Security
- **Add SRI hashes for external scripts** (when available)
- **Use crossorigin="anonymous"** for CDN resources
- **Document how to regenerate hashes** if library is updated
