# SPHERESTORM Development Rules

This document provides guidance for AI agents and developers working on the SPHERESTORM codebase.

## Game Identity

SPHERESTORM is an **arcade-style score runner** built on these pillars:

1. **Progressive Complexity** - Arenas teach mechanics incrementally
2. **Boss Puzzles** - Bosses test learned skills, not just HP pools
3. **Fast Loops** - Short early arenas, quick restarts
4. **Visual Progression** - Badges show investment and mastery
5. **Local Competition** - Leaderboards drive replayability

## Project Overview

Built with:
- **Three.js r134** (loaded via CDN, NOT npm)
- **Vanilla JavaScript** with ES Modules
- **No build system** - runs directly in browser

## Critical Rules

### 1. Three.js Usage

**DO NOT** install Three.js via npm. It's loaded via CDN:
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
```

**THREE is a global variable** - modules access it without importing.

**Use r134-compatible APIs only:**
- NO `CapsuleGeometry` (use cylinder + spheres)
- NO modern Three.js features not in r134

### 2. Module Architecture

All game code uses ES Modules. Import pattern:
```javascript
import { CONSTANT } from '../config/constants.js';
import { gameState } from '../core/gameState.js';
import { scene } from '../core/scene.js';
```

**Avoid circular dependencies:**
- Use getter functions for cross-module state
- Entity modules should not import each other's update functions

### 3. State Management

**Central state:** `js/core/gameState.js`
**Entity arrays:** `js/core/entities.js`
**Boss getter:** `getCurrentBoss()` from entities.js

### 4. Design Philosophy

#### Arena Design
Each arena should:
- Introduce ONE new mechanic
- Build on previous arena skills
- Have a boss that tests that mechanic

**Tiered Wave Counts:**
| Arena | Waves | Purpose |
|-------|-------|---------|
| 1 | 3 | Quick intro |
| 2 | 5 | Learn cover |
| 3 | 6 | Learn verticality |
| 4+ | 8-10 | Full challenge |

#### Boss Design
Bosses are **puzzle tests**, not bullet sponges:
- Phase 1: Core mechanic test
- Phase 2: Add arena twist
- Phase 3: Pressure test

Each boss failure should teach something.

#### Badge Design
- **Stat badges** - Earned during run, show build focus
- **Arena badges** - Persistent, show mastery
- Badges should be aspirational but achievable

### 5. Adding New Features

#### New Enemy Type
1. Add to `js/config/enemies.js`
2. Add behavior in `js/entities/enemies.js`
3. Set `minArena` to gate appearance

#### New Boss
1. Add to `js/config/bosses.js`
2. Add AI in `js/entities/boss.js`
3. Add arena badge in `js/config/badges.js`

#### New Arena
1. Add to `js/config/arenas.js` with:
   - `waves` count
   - `features` array
   - `teaches` description
   - `bossLesson` description
2. Add geometry in `js/arena/generator.js`

#### New Badge
1. Add to `js/config/badges.js`
2. For stat badges: set `stat` and `threshold`
3. For arena badges: set `arena` and `persistent: true`

#### New Upgrade
1. Add to `js/config/upgrades.js`
2. Ensure stat exists in `gameState.stats`
3. Consider adding a badge for high values

### 6. Code Style

**Naming:**
- Functions: `camelCase`
- Constants: `UPPER_SNAKE_CASE`
- Config objects: `UPPER_SNAKE_CASE`

**Performance:**
- Reuse `THREE.Vector3` instances
- Use `.length = 0` to clear arrays
- Pool frequently created objects

### 7. Common Patterns

**Spawn Pattern:**
```javascript
export function spawnThing(position) {
    const thing = new THREE.Mesh(geometry, material);
    thing.position.copy(position);
    scene.add(thing);
    thingsArray.push(thing);
    return thing;
}
```

**Boss AI Pattern:**
```javascript
function updateBossAI(boss) {
    if (boss.aiState === 'idle') {
        // Default behavior
        if (condition) {
            boss.aiState = 'attacking';
            boss.aiTimer = 0;
        }
    } else if (boss.aiState === 'attacking') {
        // Attack behavior
        if (boss.aiTimer > duration) {
            boss.aiState = 'idle';
        }
    }
}
```

### 8. Testing Changes

**Local server required:**
```bash
python -m http.server 8000
```

**Test checklist:**
- [ ] Game starts without errors
- [ ] Player can move and shoot
- [ ] Enemies spawn with correct behavior
- [ ] Bosses appear after final wave
- [ ] Level up menu works
- [ ] Pause/resume works
- [ ] Game over triggers correctly
- [ ] Leaderboard saves/loads
- [ ] Badges display correctly
- [ ] Arena transitions work

### 9. File Reference

| File | Purpose |
|------|---------|
| `js/main.js` | Entry point, game loop |
| `js/config/arenas.js` | Arena definitions with lore |
| `js/config/badges.js` | Badge definitions |
| `js/config/bosses.js` | Boss configurations |
| `js/config/enemies.js` | Enemy types |
| `js/core/gameState.js` | Central state |
| `js/systems/badges.js` | Badge tracking |
| `js/systems/leaderboard.js` | Score persistence |
| `js/systems/waveSystem.js` | Wave/arena progression |
| `js/ui/hud.js` | HUD updates |
| `js/ui/leaderboardUI.js` | Leaderboard display |

### 10. Balance Guidelines

**Difficulty Curve:**
- Arena 1: Learn basics, minimal challenge
- Arena 2-3: Introduce complexity gradually
- Arena 4-5: Significant challenge
- Arena 6: Endgame mastery test

**Enemy Balance:**
- Common (weight > 20): Fodder
- Uncommon (weight 10-20): Moderate threat
- Rare (weight < 10): Significant threat

**Badge Thresholds:**
- Should be achievable by wave 6-8
- Encourage specific build choices

### 11. Don'ts

- **DON'T** add npm dependencies
- **DON'T** add a build system
- **DON'T** use TypeScript
- **DON'T** create circular imports
- **DON'T** make early arenas too long
- **DON'T** make bosses pure damage sponges
- **DON'T** forget to dispose geometries/materials

## Quick Commands

```bash
# Start local server
python -m http.server 8000

# Git workflow
git add -A
git commit -m "feat: description"
git push
```
